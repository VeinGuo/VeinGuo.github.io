<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vein</title>
  <subtitle>年轻人，沉住气。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/VeinGuo/"/>
  <updated>2017-06-21T01:23:59.000Z</updated>
  <id>https://github.com/VeinGuo/</id>
  
  <author>
    <name>Vein</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/VeinGuo/2017/06/20/2017-6-15-iOS-Swift%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8VGPlayer/"/>
    <id>https://github.com/VeinGuo/2017/06/20/2017-6-15-iOS-Swift封装一个视频播放器VGPlayer/</id>
    <published>2017-06-20T07:56:54.000Z</published>
    <updated>2017-06-21T01:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-封装一个视频播放器-VGPlayer"><a href="#Swift-封装一个视频播放器-VGPlayer" class="headerlink" title="Swift 封装一个视频播放器 VGPlayer"></a>Swift 封装一个视频播放器 VGPlayer</h1><p><img src="http://upload-images.jianshu.io/upload_images/3672149-555ba04e6c5a5e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Banners.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="# 前言"></a># 前言</h2><p>之前学习了 Swift 一直想做一个项目，这次下定决心花了近1个月的空闲时间基于 AVPlayer 封装了一个视频播放器。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="# 源代码"></a># 源代码</h2><ul>
<li>GitHub地址：<a href="https://github.com/VeinGuo/VGPlayer">VGPlayer</a></li>
<li>有什么意见建议可以提 issues,在博文下留言，如果觉得不错，欢迎点star。</li>
</ul>
<h2 id="演示"><a href="#演示" class="headerlink" title="# 演示"></a># 演示</h2><p><img src="http://upload-images.jianshu.io/upload_images/3672149-8d4002b808f1637d.gif?imageMogr2/auto-orient/strip" alt="demo1.gif"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/3672149-d7eb8ea47b03b5e4.gif?imageMogr2/auto-orient/strip" alt="demo2.gif"></p>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="# 功能"></a># 功能</h2><ul>
<li>集成了视频播放器常有的手势，包括单击显示控制视图，双击暂停，水平滑动快进、后退，竖直滑动亮度和音量调节。</li>
<li>全屏播放，自适应手机屏幕旋转方向。</li>
<li>自定义控制视图</li>
</ul>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="# 实现思路"></a># 实现思路</h2><p><img src="http://upload-images.jianshu.io/upload_images/3672149-97c3599a629ed811.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图.png"></p>
<h4 id="VGPlayer"><a href="#VGPlayer" class="headerlink" title="VGPlayer"></a>VGPlayer</h4><p>VGPlayer是一个对AVPlayer封装提供播放功能，displayView为播放器画面绘制。<br>主要是使用了以下几个类：</p>
<ul>
<li>AVURLAsset是 AVAsset的子类，用来本地或者网络视频地址的初始化网络请求，也可以用来获取视频每一帧的画面来实现滑动提前预览图的功能（后续应该会版本迭代加上此功能）</li>
<li>AVPlayerItem 是对AVPlayer播放的视频数据管理，对播放的Asset资源进行记录，提供或者视频的时间，播放状态等。</li>
<li>AVPlayer 调控数据和视图</li>
<li>AVPlayerLayer 进行视频视图绘制</li>
</ul>
<p>VGPlayer封装AVPlayer提供给调用者可选代理方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// player delegate</span></div><div class="line">    <span class="comment">// play state</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayer</span><span class="params">(<span class="number">_</span> player: VGPlayer, stateDidChange state: VGPlayerState)</span></span></div><div class="line">    <span class="comment">// playe Duration</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayer</span><span class="params">(<span class="number">_</span> player: VGPlayer, playerDurationDidChange currentDuration: TimeInterval, totalDuration: TimeInterval)</span></span></div><div class="line">    <span class="comment">// buffer state</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayer</span><span class="params">(<span class="number">_</span> player: VGPlayer, bufferStateDidChange state: VGPlayerBufferstate)</span></span></div><div class="line">    <span class="comment">// buffered Duration</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayer</span><span class="params">(<span class="number">_</span> player: VGPlayer, bufferedDidChange bufferedDuration: TimeInterval, totalDuration: TimeInterval)</span></span></div><div class="line">    <span class="comment">// play error</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayer</span><span class="params">(<span class="number">_</span> player: VGPlayer, playerFailed error: VGPlayerError)</span></span></div></pre></td></tr></table></figure>
<h4 id="VGPlayerView"><a href="#VGPlayerView" class="headerlink" title="VGPlayerView"></a>VGPlayerView</h4><ul>
<li>VGPlayerView负责画面的展示,，只作为展示，而绘制层则是AVPlayerLayer提供，可继承此类进行控制视图的自定义</li>
<li>VGPlayerView封装AVPlayerLayer提供可选代理方法</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// player view delegate</span></div><div class="line">    <span class="comment">/// fullscreen</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayerView</span><span class="params">(<span class="number">_</span> playerView: VGPlayerView, willFullscreen fullscreen: Bool)</span></span></div><div class="line">    <span class="comment">/// close play view</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayerView</span><span class="params">(didTappedClose playerView: VGPlayerView)</span></span></div><div class="line">    <span class="comment">/// displaye control</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">vgPlayerView</span><span class="params">(didDisplayControl playerView: VGPlayerView)</span></span></div></pre></td></tr></table></figure>
<h4 id="VGPlayerError"><a href="#VGPlayerError" class="headerlink" title="VGPlayerError"></a>VGPlayerError</h4><ul>
<li>VGPlayerError一个 struct 用来播放出现Error时返回</li>
</ul>
<h2 id="细节调整"><a href="#细节调整" class="headerlink" title="# 细节调整"></a># 细节调整</h2><ul>
<li>后台播放的实现<br>设置工程</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3672149-679c678013de6ce7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="backgroundModes.png"></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AppDelegate settings</span></div><div class="line"> <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="comment">// Override point for customization after application launch.</span></div><div class="line">        <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">try</span> <span class="type">AVAudioSession</span>.sharedInstance().setCategory(<span class="type">AVAudioSessionCategoryPlayback</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span></div><div class="line">        &#123;</div><div class="line">            <span class="built_in">print</span>(error)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>设置VGPlayer的Background mode<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.player.backgroundMode = .proceed</div></pre></td></tr></table></figure></p>
<ul>
<li>VGPlayerUtils 提供判断视频类型方法和一些通用的方法</li>
<li>UIButton+VGPlayer 扩展按钮点击范围</li>
<li>Timer+VGPlayer 解决Timer的 retain cycle问题</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="# 参考"></a># 参考</h2><ul>
<li><a href="https://techblog.toutiao.com/2017/03/28/fullscreen/" target="_blank" rel="external">https://techblog.toutiao.com/2017/03/28/fullscreen/</a></li>
<li><a href="https://developer.apple.com/library/content/qa/qa1668/_index.html" target="_blank" rel="external">https://developer.apple.com/library/content/qa/qa1668/_index.html</a></li>
<li><a href="https://developer.apple.com/documentation/avfoundation" target="_blank" rel="external">https://developer.apple.com/documentation/avfoundation</a></li>
<li><a href="https://stackoverflow.com/questions/808503/uibutton-making-the-hit-area-larger-than-the-default-hit-area/13977921" target="_blank" rel="external">https://stackoverflow.com/questions/808503/uibutton-making-the-hit-area-larger-than-the-default-hit-area/13977921</a></li>
<li><a href="https://gist.github.com/onevcat/2d1ceff1c657591eebde" target="_blank" rel="external">https://gist.github.com/onevcat/2d1ceff1c657591eebde</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a># 总结</h2><ul>
<li>了解了AVPlayer的整体结构，对播放过程完整的思路和一些遇到的问题。</li>
<li>踩了屏幕旋转细节、按钮点击范围调整的一些交互细节的坑</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Swift-封装一个视频播放器-VGPlayer&quot;&gt;&lt;a href=&quot;#Swift-封装一个视频播放器-VGPlayer&quot; class=&quot;headerlink&quot; title=&quot;Swift 封装一个视频播放器 VGPlayer&quot;&gt;&lt;/a&gt;Swift 封装一个视频播放器 VGPlayer&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3672149-555ba04e6c5a5e30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Banners.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;# 前言&quot;&gt;&lt;/a&gt;# 前言&lt;/h2&gt;&lt;p&gt;之前学习了 Swift 一直想做一个项目，这次下定决心花了近1个月的空闲时间基于 AVPlayer 封装了一个视频播放器。&lt;/p&gt;
&lt;h2 id=&quot;源代码&quot;&gt;&lt;a href=&quot;#源代码&quot; class=&quot;headerlink&quot; title=&quot;# 源代码&quot;&gt;&lt;/a&gt;# 源代码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;GitHub地址：&lt;a href=&quot;https://github.com/VeinGuo/VGPlayer&quot;&gt;VGPlayer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;有什么意见建议可以提 issues,在博文下留言，如果觉得不错，欢迎点star。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;演示&quot;&gt;&lt;a href=&quot;#演示&quot; class=&quot;headerlink&quot; title=&quot;# 演示&quot;&gt;&lt;/a&gt;# 演示&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3672149-8d4002b808f1637d.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;demo1.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3672149-d7eb8ea47b03b5e4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;demo2.gif&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>实现一个iOS渐变背景动画效果的Switch</title>
    <link href="https://github.com/VeinGuo/2017/02/16/2017-2-16-iOS-Gradient-Switch/"/>
    <id>https://github.com/VeinGuo/2017/02/16/2017-2-16-iOS-Gradient-Switch/</id>
    <published>2017-02-16T00:16:21.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在dribbble看到一个Switch动画效果就手痒想实现，下面就是我实现的思路。</p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>GitHub地址：<a href="https://github.com/VeinGuo/VGGradientSwitch">VGGradientSwitch</a><br>如果觉得不错，欢迎点star。</p>
<h2 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h2><p>来自dribbble上的设计作者 <a href="https://dribbble.com/nick_buturishvili" target="_blank" rel="external">Nick Buturishvili</a><br><img src="https://d13yacurqjgara.cloudfront.net/users/408943/screenshots/2272690/switch.gif" alt="image"></p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://ojaltanzc.bkt.clouddn.com/switch_button_1.gif" alt="image"><br><a id="more"></a></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>首先解刨一下设计图</li>
</ul>
<ol>
<li>外观和iOS原生UISwitch相同</li>
<li>观察动图发现Switch背景图为渐变色，这也是这个开关设计的一大亮点</li>
<li>开关上的纽扣，打开时状态是一个勾，关闭时是一个叉。</li>
<li>打开动画，勾边线放大移动边做形变变成点再变换成叉放大后恢复原状，背景颜色由青色转换到橘黄色。</li>
<li>关闭动画，叉边先放大移动边做形变再变成勾放大后恢复原状，背景颜色由橘黄色转换到青色</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>渐变背景图是通过<code>CAGradientLayer</code>实现。通过设计图取色拿到颜色十六进制(0x08ded6,0x18deb9,0xef9c29,0xe76b39)四个颜色,创建出一个3倍的switch宽度渐变图<br>如图: <img src="http://upload-images.jianshu.io/upload_images/3672149-30b1f130c7724472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">gradientLayer.locations = @[@0, @.33, @.63, @1];</div><div class="line">gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">gradientLayer.endPoint = CGPointMake(1, 0);</div><div class="line">gradientLayer.frame = CGRectMake(0, 0, self.frame.size.width * 3, self.frame.size.height);</div></pre></td></tr></table></figure>
<ul>
<li>边框使用<code>UIBezierPath</code>设置一个圆角边框</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/3672149-16dc2c56abc88cf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>勾、点和叉的实现使用到<code>UIBezierPath</code>提供path，然后<code>CAShapeLayer</code>创建，勾图形实现代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">UIBezierPath *tickPath = [UIBezierPath bezierPath];</div><div class="line">[tickPath moveToPoint:CGPointMake(self.frame.size.width/8 * 3, self.frame.size.width/2)];</div><div class="line">CGPoint p1 = CGPointMake(self.frame.size.width/2, self.frame.size.width/8 * 5);</div><div class="line">[tickPath addLineToPoint:p1];</div><div class="line">CGPoint p2 = CGPointMake(self.frame.size.width/8 * 6, self.frame.size.width/8 * 3);</div><div class="line">[tickPath addLineToPoint:p2];</div><div class="line"></div><div class="line">CAShapeLayer *layer = [[CAShapeLayer alloc] init];</div><div class="line">layer.lineCap = kCALineCapRound;</div><div class="line">layer.lineJoin = kCALineJoinRound;</div><div class="line">layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">layer.strokeColor = [UIColor whiteColor].CGColor;</div><div class="line">layer.lineWidth = 2;</div><div class="line">layer.path = tickPath.CGPath;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/3672149-8012e458f4808968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<ul>
<li>渐变背景颜色的动画效果，笔者是将<code>CAGradientLayer</code>添加到一个UIView上然后直接使用，UIView的动画方法然后做位移，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[UIView animateKeyframesWithDuration:.5 delay:.1 options:UIViewKeyframeAnimationOptionCalculationModePaced animations:^&#123;</div><div class="line">        self.gradientView.frame = CGRectMake(-self.frame.size.width *2, 0, self.frame.size.width *3, self.frame.size.height);</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">    </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/3672149-e93f0003fde40f55.gif?imageMogr2/auto-orient/strip" alt="image"></p>
<ul>
<li>图形形变动画主要利用<code>Core Animation</code>实现,用到了<code>CAKeyframeAnimation</code>、<code>CABasicAnimation</code>、<code>CAAnimationGroup</code></li>
<li>勾-&gt;点动画  先放大勾后然后做缩小形变成点 </li>
<li>点-&gt;勾动画  做形变成勾后做放大</li>
<li><p>动画使用了”path”和”transform”，形变动画使用path提供路径数组，这里提供原本勾的路径和点的路径这样路径就从勾形变到点<br>代码如下:</p>
</li>
<li><p>放大动画 使用<code>CABasicAnimation</code></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];</div><div class="line">CATransform3D tr = CATransform3DIdentity;</div><div class="line">tr = CATransform3DTranslate(tr, _rect.size.width/2, _rect.size.height/2, 0);</div><div class="line">tr = CATransform3DScale(tr, 1.2, 1.2, 1);</div><div class="line">tr = CATransform3DTranslate(tr, -_rect.size.width/2, -_rect.size.height/2, 0);</div><div class="line">animation.toValue = [NSValue valueWithCATransform3D:tr];</div><div class="line">animation.autoreverses = YES;</div><div class="line">animation.timingFunction  = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div></pre></td></tr></table></figure>
<ul>
<li>形变动画 使用<code>CAKeyframeAnimation</code>具体的使用可以Google一下这里就不多赘言,<code>values</code>传入的是勾的path和点path</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">animation.values = values;</div><div class="line">animation.keyTimes = keyTimes;</div><div class="line">animation.beginTime = beginTime;</div></pre></td></tr></table></figure>
<ul>
<li>使用<code>CAAnimationGroup</code>做组合动画,组合动画代理方法可以判断组合动画是否完成，<code>&lt;CAAnimationDelegate&gt;</code> 代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// scaleAnimation 放大 lineAnimation线条形变</div><div class="line">  CAAnimationGroup *animationGroup = [CAAnimationGroup animation];</div><div class="line">  animationGroup.animations = @[scaleAnimation,lineAnimation];</div><div class="line">  animationGroup.duration = .5;</div><div class="line">  animationGroup.repeatCount = 1;</div><div class="line">  animationGroup.removedOnCompletion = NO;</div><div class="line">  animationGroup.fillMode = kCAFillModeForwards;</div><div class="line">  animationGroup.timingFunction  = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">  animationGroup.delegate = self;</div><div class="line">  </div><div class="line">  // CAAnimationDelegate  动画是否结束</div><div class="line">  - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/3672149-6989c7df61f3ff5b.gif?imageMogr2/auto-orient/strip" alt="image"></p>
<ul>
<li>剩下的就是移动这个按钮然后由点形变成叉这里就不再说明，可以直接看GitHub代码,以上就是分解动画的一些思路和解决办法，但是动画要流畅和交互不违和还需要细微调整</li>
<li>有什么代码和实现的效果建议可以提issue给我，如果喜欢的话点一下 star 哦</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在dribbble看到一个Switch动画效果就手痒想实现，下面就是我实现的思路。&lt;/p&gt;
&lt;h2 id=&quot;源代码&quot;&gt;&lt;a href=&quot;#源代码&quot; class=&quot;headerlink&quot; title=&quot;源代码&quot;&gt;&lt;/a&gt;源代码&lt;/h2&gt;&lt;p&gt;GitHub地址：&lt;a href=&quot;https://github.com/VeinGuo/VGGradientSwitch&quot;&gt;VGGradientSwitch&lt;/a&gt;&lt;br&gt;如果觉得不错，欢迎点star。&lt;/p&gt;
&lt;h2 id=&quot;设计图&quot;&gt;&lt;a href=&quot;#设计图&quot; class=&quot;headerlink&quot; title=&quot;设计图&quot;&gt;&lt;/a&gt;设计图&lt;/h2&gt;&lt;p&gt;来自dribbble上的设计作者 &lt;a href=&quot;https://dribbble.com/nick_buturishvili&quot;&gt;Nick Buturishvili&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;https://d13yacurqjgara.cloudfront.net/users/408943/screenshots/2272690/switch.gif&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ojaltanzc.bkt.clouddn.com/switch_button_1.gif&quot; alt=&quot;image&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://github.com/VeinGuo/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS Memory management</title>
    <link href="https://github.com/VeinGuo/2016/12/29/iOS-Memory-management/"/>
    <id>https://github.com/VeinGuo/2016/12/29/iOS-Memory-management/</id>
    <published>2016-12-28T21:44:29.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="# 前言"></a># 前言</h2><blockquote>
<p>反复地复习iOS基础知识和原理，打磨知识体系是非常重要的，本篇就是重新温习iOS的内存管理。</p>
</blockquote>
<p>内存管理是管理对象生命周期，在对象不需要时进行内存释放的编程规范。</p>
<h2 id="MRR时代"><a href="#MRR时代" class="headerlink" title="# MRR时代"></a># MRR时代</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Objective-C内存管理使用使用引用计数(Reference Counting)来管理内存。</p>
<blockquote>
<p>在OS X 10.8以后也不再使用垃圾回收机制，iOS则从来都没有支持垃圾回收机制。</p>
</blockquote>
<p>当<code>create</code>或者<code>copy</code>对象时，会计数为1，其他对象需要<code>retain</code>时，会增加引用计数。持有对象的所有者也可以放弃所有权，放弃所有权时减少计数，当计数为0时就会释放对象。<br>如图：</p>
<p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-29-memory-management/memory_management_2x.png" alt="memory_management"><br><a id="more"></a></p>
<h4 id="Memory-Management-Policy-内存管理策略"><a href="#Memory-Management-Policy-内存管理策略" class="headerlink" title="Memory Management Policy 内存管理策略"></a>Memory Management Policy 内存管理策略</h4><ul>
<li>通过分配内存或<code>copy</code>来创建任何对象</li>
<li>使用方法 <code>alloc</code>, <code>allocWithZone:</code>, <code>copy</code>, <code>copyWithZone:</code>, <code>mutableCopy</code> , <code>mutableCopyWithZone:</code>创建对象</li>
<li>通过<code>retain</code>来获取不是自己创建对象的所有权。以下两种情况使用<code>retain</code>:<ol>
<li>在<code>accessor method</code>或者<code>init method</code>方法获取所需要的对象所有权为属性<code>property</code> 。</li>
<li>需要操作对象时，避免对象被释放而导致错误，需要<code>retain</code>持有对象。</li>
</ol>
</li>
<li>发送<code>release</code>, <code>autorelease</code>消息来释放不需要的对象。</li>
<li>不要不是你创建的对象和没有所有权的对象发送<code>release</code>消息。</li>
</ul>
<h4 id="Practical-Memory-Management-实际内存管理"><a href="#Practical-Memory-Management-实际内存管理" class="headerlink" title="Practical Memory Management 实际内存管理"></a>Practical Memory Management 实际内存管理</h4><ul>
<li><p>Autorelease pools</p>
<ul>
<li>向对象发送<code>autorelease</code>消息，会将对象标记为延迟释放，当对象超出当前作用域时，释放对象。</li>
<li><p><code>AppKit frameworks</code>和<code>UIKit frameworks</code>在事件循环的每个周期开始时，在主线程上创建一个自动释放池，并在此次时间循环结束时，释放它，从而释放在处理时生成的所有自动释放的对象。因此，通常不需要自己创建<code>autoreleasePool</code>，当然，以下情况你需要自己创建和销毁<code>autoreleasePool</code>：</p>
<ol>
<li>如果你编写的代码不是基于<code>UI framework</code>的程序，如<code>command-line tool</code>命令行工具。</li>
<li>如果你需要写一个循环，创建许多临时对象，如读入大量的铜像同时改变图片尺寸，图像读入到<code>NSData</code>对象，并从中生成<code>UIImage</code>对象，改变该对象尺寸生成新的<code>UIImage</code>对象。</li>
<li>如果你创建一个长期存在线程并且可能产生大量的<code>autorelease</code>对象。</li>
</ol>
</li>
</ul>
</li>
<li><p><code>autoreleasePool</code>推荐使用以下方法：</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">	<span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>dealloc</p>
</li>
<li><p>当<code>NSObject</code>对象的引用计数为0时，销毁该对象前会调用<code>dealloc</code>方法，用来释放该对象拥有的所有资源，包裹实例变量指向的对象。<br>  例子:</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//	MRR</span></div><div class="line">- (<span class="keyword">void</span>)dealloc&#123;</div><div class="line">   [_firstName release];</div><div class="line">   [_lastName release];</div><div class="line">   [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Important: Never invoke another object’s dealloc method directly.You must invoke the superclass’s implementation at the end of your implementation.You should not tie management of system resources to object lifetimes; see Don’t Use dealloc to Manage Scarce Resources.When an application terminates, objects may not be sent a dealloc message. Because the process’s memory is automatically cleared on exit, it is more efficient simply to allow the operating system to clean up resources than to invoke all the memory management methods.<br>不要直接调用另一个对象的dealloc方法。<br>你必须在类使用结束时调用父类的实现。<br>你不应该把系统资源与对象的生命周期绑定。<br>因为进程的内存退出时，对象可能无法发送dealloc消息,该方法的内存被自动退出清零,所以让操作系统清理资源比调用所有的内存管理方法更有效。</p>
</blockquote>
<h3 id="内存管理实践"><a href="#内存管理实践" class="headerlink" title="内存管理实践"></a>内存管理实践</h3><h4 id="使用访问器方法使内存管理更轻松"><a href="#使用访问器方法使内存管理更轻松" class="headerlink" title="使用访问器方法使内存管理更轻松"></a>使用访问器方法使内存管理更轻松</h4><blockquote>
<p>如果类有一个属性是一个对象，你必须确保使用该对象时，它不会被释放。因此在设置时，必须声明对象的所有权。还必须保证持有这些对象所有权的放弃。</p>
</blockquote>
<ul>
<li>使用<code>set</code>和<code>get</code>方法来实现，更方便管理内存（主要是省写很多<code>retain</code>和<code>release</code>）。<br>例子如下：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Counter</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">NSNumber</span> *count;</div><div class="line"><span class="keyword">@end</span>;</div></pre></td></tr></table></figure>
<p><code>Counter</code>类有一个属性是<code>NSNumber</code>对象，属性声明了<code>set</code>和<code>get</code>两个访问器方法，在<code>get</code>中就是返回<code>synthesized</code>实例变量，所以没必要<code>retain</code>或者<code>release</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSNumber</span> *)count &#123;</div><div class="line">	<span class="keyword">return</span> _count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>set</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setCount:(<span class="built_in">NSNumber</span> *)newCount &#123;</div><div class="line">    [newCount <span class="keyword">retain</span>]; <span class="comment">// 先`retain`确保新数据不被释放</span></div><div class="line">    [_count release];  <span class="comment">// 释放旧对象所有权</span></div><div class="line">    <span class="comment">// Make the new assignment.</span></div><div class="line">    _count = newCount; 	<span class="comment">// 将新值赋给_count</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先<code>retain</code>确保新数据不被释放，释放旧的对象所有权(Objective-C允许向<code>nil</code>发送消息)。你必须在<code>[newCount retain]</code>之后再<code>[_count release]</code>确保外部不会被<code>dealloc</code>。</p>
<h4 id="使用访问器方法设置属性"><a href="#使用访问器方法设置属性" class="headerlink" title="使用访问器方法设置属性"></a>使用访问器方法设置属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法一</span></div><div class="line">- (<span class="keyword">void</span>)reset &#123;</div><div class="line">    <span class="built_in">NSNumber</span> *zero = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</div><div class="line">    [<span class="keyword">self</span> setCount:zero];</div><div class="line">    [zero release];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 方法二</span></div><div class="line">- (<span class="keyword">void</span>)reset &#123;</div><div class="line">    <span class="built_in">NSNumber</span> *zero = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</div><div class="line">    [_count release];</div><div class="line">    _count = zero;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法二没有对<code>count</code>属性赋新值时没有使用<code>set</code>访问方法，也不会触发<code>KVO</code>，可能在特殊情况导致错误（比如忘记了 <code>retain</code>或者<code>release</code>，或者如果实例变量的内存管理发生了变化）。除了第一种方法，或者直接使用<code>self.count = zero;</code>。</p>
<h4 id="不要在初始化和dealloc中使用访问器方法"><a href="#不要在初始化和dealloc中使用访问器方法" class="headerlink" title="不要在初始化和dealloc中使用访问器方法"></a>不要在初始化和<code>dealloc</code>中使用访问器方法</h4><p>不应该使用<code>set</code>和<code>get</code>方法在<code>init</code>和<code>dealloc</code>。应该使用<code>_</code>直接访问成员变量进行初始化和<code>dealloc</code>。如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _count = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 由于Counter类具有对象实例变量，因此还必须实现dealloc方法。</span></div><div class="line"><span class="comment">// 它应该通过向任何实例变量发送一个释放消息来放弃它的所有权，最终它应该调用super的实现</span></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [_count release];</div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="使用弱引用来避免循环引用"><a href="#使用弱引用来避免循环引用" class="headerlink" title="使用弱引用来避免循环引用"></a>使用弱引用来避免循环引用</h4><ul>
<li><code>retain</code>对象，实际是对对象的强引用(strong reference),一个对象在所有强引用都没有被释放之前，不能释放对象。因此，如果有两个对象互相持有对方或者间接互相引用，会导致循环引用。这时候就需要弱引用对方来打破这个循环。</li>
</ul>
<p>如父亲强引用儿子，儿子强引用孙子，那么倒过来孙子只能弱引用儿子，儿子也只能弱引用父亲。<code>Cocoa</code>建立了一个约定，副对象应该强引用子对象，并且子对象应该只对父对象弱引用。<br><code>Cocoa</code>中常见的例子包括代理方法<code>delegate</code>，<code>data source</code>,<code>observer</code>,<code>target</code>等等</p>
<p>必须小心将消息发送到持有只是一个弱引用的对象。当发送消息给一个被<code>dealloc</code>的弱引用对象时，你的应用程序会崩溃（这是在<code>MRR</code>时期的代理<code>delegate</code>会出现，因为当时对代理弱引用的修饰符是<code>assign</code>,<code>assign</code>弱引用并不会在对象<code>dealloc</code>时，把对象置为<code>nil</code>。而<code>ARC</code>时代使用<code>weak</code>则会在对象<code>dealloc</code>时置为<code>nil</code>）。</p>
<h4 id="避免正在使用的对象被释放"><a href="#避免正在使用的对象被释放" class="headerlink" title="避免正在使用的对象被释放"></a>避免正在使用的对象被释放</h4><ul>
<li><code>Cocoa</code>的所有权策略规定接收的对象通常在整个调用方法的范围内保证有效。还应该是在当前方法范围内，而不必担心它被释放。对象的<code>getter</code>方法返回一个缓存的实例变量或者一个计算的值，这不重要，重要的是，对象在需要的使用时还是有效的。</li>
<li><p>有两类例外情况：</p>
<ul>
<li><p>当一个对象从基本的集合类删除时</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">heisenObject = [array objectAtIndex:n];</div><div class="line">[array removeObjectAtIndex:n];</div><div class="line"><span class="comment">// heisenObject 现在可能无效</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- `n`从集合`array`删除时也会向`n`发送`release`（而不是`autorelease`）消息。如果`array`集合时被删除`n`对象的唯一拥有者，被移除的对象`n`是立即被释放的。`heisenObject`并没有对`n`进行`retain`，所以当`n`从`array`删除时同时被释放。

**正确的做法**

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">heisenObject = [[array objectAtIndex:n] <span class="keyword">retain</span>];</div><div class="line">[array removeObjectAtIndex:n];</div><div class="line"><span class="comment">// Use heisenObject...</span></div><div class="line">[heisenObject release];</div></pre></td></tr></table></figure>

- 当一个父对象被释放时

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> parent = &lt;<span class="meta">#create a parent object#&gt;;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line">heisenObject = [parent child] ;</div><div class="line">[parent release]; <span class="comment">// Or, for example: self.parent = nil;</span></div><div class="line"><span class="comment">// heisenObject 现在可能无效</span></div></pre></td></tr></table></figure>
</code></pre><ul>
<li>在某些情况下，从另一个对象获取的对象，然后直接或者间接的释放负对象。如果释放父对象导致它被释放，并且父对象是子对象唯一所有者，那么子对象<code>heisenObject</code>将被同一时间释放。所以正确的做法还是子对象<code>heisenObject</code>获取的时候先<code>retain</code>一次。</li>
</ul>
<h4 id="Collections类拥有它们所包含的对象所有权"><a href="#Collections类拥有它们所包含的对象所有权" class="headerlink" title="Collections类拥有它们所包含的对象所有权"></a>Collections类拥有它们所包含的对象所有权</h4><ul>
<li>添加一个对象到一个<code>collection</code>中，如(数组、字典、集合)时，<code>collection</code>会得到该对象所有权。当对象从<code>collection</code>删除或者<code>collection</code>自己被释放时，<code>collection</code>将释放它拥有的所有权。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = &lt;<span class="meta">#Get a mutable array#&gt;;</span></div><div class="line"><span class="built_in">NSUInteger</span> i;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    <span class="built_in">NSNumber</span> *allocedNumber = [[<span class="built_in">NSNumber</span> alloc] initWithInteger:i];</div><div class="line">    [array addObject:allocedNumber];</div><div class="line">    [allocedNumber release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="通过引用计数实现所有所有权策略"><a href="#通过引用计数实现所有所有权策略" class="headerlink" title="通过引用计数实现所有所有权策略"></a>通过引用计数实现所有所有权策略</h4><ul>
<li><p>所有圈策略是通过引用计数实现的，通常<code>retain</code>方法后被称为<code>retain count</code>。每个对象都有一个引用计数。</p>
<ul>
<li>当你创建一个对象，它的引用计数为<code>1</code></li>
<li>当你给对象发送<code>retain</code>消息，引用计数<code>+1</code></li>
<li>当你给对象发送<code>release</code>消息，引用计数<code>-1</code></li>
<li>当你给对象发送一个<code>autorelease</code>消息，它的引用计数器将在当前的自动释放池结束后<code>-1</code></li>
<li>当对象的引用计数为<code>0</code>时将被释放</li>
</ul>
</li>
</ul>
<h2 id="ARC时代"><a href="#ARC时代" class="headerlink" title="# ARC时代"></a># ARC时代</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p>iOS5后出现了<code>ARC</code>。那么<code>ARC</code>是什么呢？<br>自动引用计数<code>ARC</code>是一种编译器的功能，为<code>Objective-C</code>对象提供了自动化的内存管理。<br>在<code>ARC</code>不需要开发者考虑保留或者释放的操作，就是不用自己手动<code>retain</code>、<code>release</code>和<code>autorelease</code>（😄开心），让开发者可以专注写有趣的代码。</p>
<p><strong>当然<code>ARC</code>依然是基于引用计数管理内存。</strong></p>
<h3 id="ARC-强制新规则"><a href="#ARC-强制新规则" class="headerlink" title="ARC 强制新规则"></a>ARC 强制新规则</h3><p><code>ARC</code>相对于<code>MRR</code>强制加了一些新的规则。</p>
<ul>
<li>你不能主动调用<code>dealloc</code>、或者调用<code>retain</code>,<code>release</code>, <code>retainCount</code>,<code>autorelease</code>就是这些都不用你写了。也不能<code>@selector(retain)</code>, <code>@selector(release)</code>这样子调用。</li>
<li>你可以实现一个<code>dealloc</code>方法，如果你需要管理资源而不是释放实例变量(比如解除监听、释放引用、socket close等等)。在重写<code>dealloc</code>后需要<code>[super dealloc]</code>（在手动管理引用计数时才需要）。</li>
<li>仍然可以使用<code>CFRetain</code>，<code>CFRelease</code>等其它对象。</li>
<li>你不能使用<code>NSAllocateObject</code>或者<code>NSDeallocateObject</code>。</li>
<li>你不能使用<code>C</code>结构体，可以创建一个<code>Objective-C</code>类去管理数据而不是一个结构体。</li>
<li><code>id</code>和<code>void</code>没有转换关系,你必须使用<code>cast</code>特殊方式，以便在作为函数参数传递的<code>Objective-C</code>对象和<code>Core Foundation</code>类型之间进行转换。</li>
<li>你不能使用<code>NSAutoreleasePool</code>，使用<code>@autoreleasepool</code>。</li>
<li>没必要使用<code>NSZone</code></li>
</ul>
<h3 id="ARC-使用新修饰符"><a href="#ARC-使用新修饰符" class="headerlink" title="ARC 使用新修饰符"></a>ARC 使用新修饰符</h3><ul>
<li><code>__strong</code> 强引用,用来保证对象不会被释放。</li>
<li><code>__weak</code>弱引用 释放时会置为<code>nil</code></li>
<li><code>__unsafe_unretained</code>弱引用 可能不安全，因为释放时不置为<code>nil</code>。</li>
<li><code>__autoreleasing</code>对象被注册到<code>autorelease pool</code>中方法在返回时自动释放。</li>
</ul>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p><code>ARC</code>还是基于引用计数的管理机制所以依然会出现循环引用。</p>
<h4 id="block使用中出现循环引用"><a href="#block使用中出现循环引用" class="headerlink" title="block使用中出现循环引用"></a>block使用中出现循环引用</h4><ul>
<li>常见的有情况在<code>block</code>使用中出现循环引用</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 情况一</span></div><div class="line"><span class="keyword">self</span>.myBlock = ^&#123;</div><div class="line"><span class="keyword">self</span>.objc = ...;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 情况二</span></div><div class="line">Dog *dog = [[Dog alloc] init];</div><div class="line">dog.myBlock = ^&#123;</div><div class="line">	 <span class="comment">// do something</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">self</span>.dog = dog;</div></pre></td></tr></table></figure>
<pre><code>- 解决方法

<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span> (<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="keyword">self</span>.myBlock = ^&#123;</div><div class="line">weakSelf.objc = ...;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>那么如果<code>block</code>内使用了<code>self</code>这个时候如果某一个时刻<code>self</code>被释放就会导致出现问题。</p>
</li>
<li><p>解决方法</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span> (<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line"><span class="keyword">self</span>.myBlock = ^&#123;</div><div class="line">__<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</div><div class="line">strongSelf.objc1 = ...;</div><div class="line">strongSelf.objc2 = ...;</div><div class="line">strongSelf.objc3 = ...;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>使用<code>__weak</code>打破循环引用。<code>__strong</code>用来避免在使用<code>self</code>过程中<code>self</code>被释放，<code>__strong</code>在<code>block</code>后会调用<code>objc_release(obj)</code>释放对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">	</div><div class="line"><span class="comment">// clang 编译后</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure>
<p>两次调用<code>objc_msgSend</code>并在变量作用域结束时调用<code>objc_release</code>释放对象，不会出现循环引用问题。</p>
<h4 id="NSTimer循环引用"><a href="#NSTimer循环引用" class="headerlink" title="NSTimer循环引用"></a>NSTimer循环引用</h4><p>为什么<code>NSTimer</code>会导致循环引用呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti </div><div class="line">									  target:(<span class="keyword">id</span>)aTarget </div><div class="line">									  selector:(SEL)aSelector </div><div class="line">									  userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo </div><div class="line">									  repeats:(<span class="built_in">BOOL</span>)yesOrNo;</div><div class="line">									  </div><div class="line">									  </div><div class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti </div><div class="line">										        target:(<span class="keyword">id</span>)aTarget </div><div class="line">										        selector:(SEL)aSelector </div><div class="line">										        userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo </div><div class="line">										        repeats:(<span class="built_in">BOOL</span>)yesOrNo;</div></pre></td></tr></table></figure>
<ul>
<li><p>主要是因为<code>NSRunloop</code>运行循环保持了对<code>NSTimer</code>的强引用，并且<code>NSTimer</code>的<code>targer</code>也使用了强引用。</p>
</li>
<li><p>来自文档<a href="https://developer.apple.com/reference/foundation/nstimer?language=objc" target="_blank" rel="external">NSTimer</a></p>
</li>
</ul>
<blockquote>
<p>Note in particular that run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop.<br><strong>target</strong><br>The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated.</p>
</blockquote>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">viewControllerDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimer</span> *timer;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"> - (<span class="keyword">void</span>)viewDidLoad</div><div class="line"> &#123;</div><div class="line">     [<span class="keyword">super</span> viewDidLoad];</div><div class="line">     <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span></div><div class="line">                                               target:<span class="keyword">self</span> </div><div class="line">                                             selector:<span class="keyword">@selector</span>(onTimeOut:) </div><div class="line">                                             userInfo:<span class="literal">nil</span> </div><div class="line">                                              repeats:<span class="literal">NO</span>];</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>这里控制器强引用了<code>timer</code>，而<code>timer</code>也强引用了控制器,这个时候就是循环引用了，引用关系如下图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">timer-&gt;控制器:strong</div><div class="line">控制器-&gt;timer:strong</div></pre></td></tr></table></figure>
<ul>
<li>那么如果控制器对<code>timer</code>使用了<code>weak</code>呢？<br>使用<code>weak</code>是打破了循环引用,但是<code>run loop</code>还是强引用着<code>timer</code>,<code>timer</code>又强引用着控制器，所以还是会导致内存泄漏。引用关系如下图：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">runloop-&gt;timer:strong</div><div class="line">timer-&gt;控制器:strong</div><div class="line">控制器--&gt;timer:weak</div></pre></td></tr></table></figure>
<p>如果我们把<code>timer</code>加入主线程的<code>runloop</code>,主线程中的<code>runloop</code>生命周期只有主线程结束才会销毁，所以我们不主动调用<code>[timer invalidate]</code>,<code>runloop</code>会一直持有<code>timer</code>，<code>timer</code>又持有控制器，那么就一直不会释放控制器。</p>
<ul>
<li>解决方法：手动调用<code>[timer invalidate]</code>来解除持有关系，释放内存。可能会想到在<code>dealloc</code>方法中来手动调用，但是因为<code>timer</code>持有控制器，所以控制器的<code>dealloc</code>方法永远不会调用，因为<code>dealloc</code>是在控制器要被释放前调用的。在<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Timers/Articles/usingTimers.html" target="_blank" rel="external">Timer Programming Topics</a>中有特别说明。所以一般我们可以在下面这些方法中手动调用<code>[timer invalidate]</code>然后置为<code>nil</code>：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated; <span class="comment">// Called when the view is dismissed, covered or otherwise hidden. Default does nothing</span></div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated;  <span class="comment">// Called after the view was dismissed, covered or otherwise hidden. Default does nothing</span></div></pre></td></tr></table></figure>
<blockquote>
<p>A timer maintains a strong reference to its target. This means that as long as a timer remains valid, its target will not be deallocated. As a corollary, this means that it does not make sense for a timer’s target to try to invalidate the timer in its dealloc method—the dealloc method will not be invoked as long as the timer is valid.</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="# 参考资料"></a># 参考资料</h2><ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011-SW1" target="_blank" rel="external">About Memory Management</a></li>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
<li><a href="https://developer.apple.com/reference/foundation/nstimer?language=objc" target="_blank" rel="external">NSTimer</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Timers/Articles/usingTimers.html" target="_blank" rel="external">Timer Programming Topics</a></li>
<li><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="external">《Effective Objective-C 2.0 编写高质量iOS与OS X代码的52个有效方法》</a></li>
<li><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">《objc高级编程:iOS与OS X多线程和内存管理》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;# 前言&quot;&gt;&lt;/a&gt;# 前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;反复地复习iOS基础知识和原理，打磨知识体系是非常重要的，本篇就是重新温习iOS的内存管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;内存管理是管理对象生命周期，在对象不需要时进行内存释放的编程规范。&lt;/p&gt;
&lt;h2 id=&quot;MRR时代&quot;&gt;&lt;a href=&quot;#MRR时代&quot; class=&quot;headerlink&quot; title=&quot;# MRR时代&quot;&gt;&lt;/a&gt;# MRR时代&lt;/h2&gt;&lt;h3 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h3&gt;&lt;p&gt;Objective-C内存管理使用使用引用计数(Reference Counting)来管理内存。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在OS X 10.8以后也不再使用垃圾回收机制，iOS则从来都没有支持垃圾回收机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当&lt;code&gt;create&lt;/code&gt;或者&lt;code&gt;copy&lt;/code&gt;对象时，会计数为1，其他对象需要&lt;code&gt;retain&lt;/code&gt;时，会增加引用计数。持有对象的所有者也可以放弃所有权，放弃所有权时减少计数，当计数为0时就会释放对象。&lt;br&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojaltanzc.bkt.clouddn.com/2016-12-29-memory-management/memory_management_2x.png&quot; alt=&quot;memory_management&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://github.com/VeinGuo/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>NSNotificationCenter实现原理？</title>
    <link href="https://github.com/VeinGuo/2016/12/21/NSNotificationCenter%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/"/>
    <id>https://github.com/VeinGuo/2016/12/21/NSNotificationCenter实现原理？/</id>
    <published>2016-12-21T01:07:05.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="#前言"></a>#前言</h2><p>Cocoa中使用NSNotification、NSNotificationCenter和KVO来实现观察者模式，实现对象间一对多的依赖关系。</p>
<p>本篇文章主要来讨论NSNotification和NSNotificationCenter</p>
<h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="# NSNotification"></a># NSNotification</h2><p><code>NSNotification</code>是方便<code>NSNotificationCenter</code>广播到其他对象时的封装对象，简单讲即通知中心对通知调度表中的对象广播时发送<code>NSNotification</code>对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSNotification</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSNotificationName</span> name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="keyword">id</span> object;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *userInfo;</div></pre></td></tr></table></figure>
<p><code>NSNotification</code>对象包含名称、object、字典三个属性，名称是用来标识通知的标记，object是要通知的对象可以为<code>nil</code>,字典用来存储发送通知时附带的信息，也可以为<code>nil</code>。<br><a id="more"></a></p>
<h2 id="NSNotificationCenter"><a href="#NSNotificationCenter" class="headerlink" title="# NSNotificationCenter"></a># NSNotificationCenter</h2><p><code>NSNotificationCenter</code>是类似一个广播中心站，使用<code>defaultCenter</code>来获取应用中的通知中心，它可以向应用任何地方发送和接收通知。在通知中心注册观察者，发送者使用通知中心广播时，以<code>NSNotification</code>的<code>name</code>和<code>object</code>来确定需要发送给哪个观察者。为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。</p>
<h3 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h3><p>发送通知可使用以下方法发送通知</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)postNotification:(<span class="built_in">NSNotification</span> *)notification;</div><div class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div><div class="line">- (<span class="keyword">void</span>)postNotificationName:(<span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject userInfo:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)aUserInfo;</div></pre></td></tr></table></figure>
<ul>
<li><p>三种方式实际上都是发送<code>NSNotification</code>对象给通知中心注册的观察者。</p>
</li>
<li><p>发送通知通过name和object来确定来标识观察者,name和object两个参数的规则相同即当通知设置name为kChangeNotifition时，那么只会发送给符合name为kChangeNotifition的观察者，同理object指发送给某个特定对象通知，如果只设置了name，那么只有对应名称的通知会触发。如果同时设置name和object参数时就必须同时符合这两个条件的观察者才能接收到通知。</p>
</li>
</ul>
<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>你可以使用以下两种方式注册观察者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserver:(<span class="keyword">id</span>)observer selector:(SEL)aSelector name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>&gt;)addObserverForName:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)name object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)obj queue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSNotification</span> *note))block <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</div><div class="line">    <span class="comment">// The return value is retained by the system, and should be held onto by the caller in</span></div><div class="line">    <span class="comment">// order to remove the observer with removeObserver: later, to stop observation.</span></div></pre></td></tr></table></figure>
<ol>
<li>第一种方式是比较常用的添加<code>Oberver</code>的方式，接到通知时执行aSelector。</li>
<li>第二种方式是基于Block来添加观察者，往通知中心的调度表中添加观察者，这个观察者包括一个<code>queue</code>和一个<code>block</code>,并且会返回这个观察者对象。当接到通知时执行<code>block</code>所在的线程为添加观察者时传入的<code>queue</code>参数，<code>queue</code>也可以为<code>nil</code>，那么<code>block</code>就在通知所在的线程同步执行。</li>
</ol>
<p><strong>这里需要注意的是如果使用第二种的方式创建观察者需要弱引用可能引起循环引用的对象,避免内存泄漏。</strong></p>
<h3 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h3><p>在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。<br>移除观察者有两种方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer;</div><div class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="keyword">id</span>)observer name:(<span class="keyword">nullable</span> <span class="built_in">NSNotificationName</span>)aName object:(<span class="keyword">nullable</span> <span class="keyword">id</span>)anObject;</div></pre></td></tr></table></figure>
<ul>
<li>传入相应的需要移除的<code>observer</code> 或者使用第二种方式三个参数来移除指定某个观察者。</li>
<li>如果使用基于<code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]</code>方法在获取方法返回的观察者进行释放。基于这个方法我们还可以让观察者接到通知后只执行一次：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__block __<span class="keyword">weak</span> <span class="keyword">id</span>&lt;<span class="built_in">NSObject</span>&gt; observer = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:kChangeNotifition object:<span class="literal">nil</span> queue:[<span class="built_in">NSOperationQueue</span> mainQueue] usingBlock:^(<span class="built_in">NSNotification</span> * _Nonnull note) &#123;</div><div class="line">       <span class="built_in">NSLog</span>(<span class="string">@"-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]"</span>);</div><div class="line">      [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:observer];</div><div class="line">   &#125;];</div></pre></td></tr></table></figure>
<p>在<code>iOS9</code>中调整了<code>NSNotificatinonCenter</code><br><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-21-Notification/NSNotificationCenter.png" alt="NSNotification"><br><code>iOS9</code>开始不需要在观察者对象释放之前从通知中心移除观察者了。但是如果使用<code>-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]</code>方法还是需要手动释放。因为<code>NSNotificationCenter</code>依旧对它们强引用。</p>
<h2 id="NSNotificationQueue"><a href="#NSNotificationQueue" class="headerlink" title="# NSNotificationQueue"></a># NSNotificationQueue</h2><p><code>NSNotificationQueue</code>通知队列，用来管理多个通知的调用。通知队列通常以先进先出（FIFO）顺序维护通。<code>NSNotificationQueue</code>就像一个缓冲池把一个个通知放进池子中，使用特定方式通过<code>NSNotificationCenter</code>发送到相应的观察者。下面我们会提到特定的方式即合并通知和异步通知。</p>
<ul>
<li>创建通知队列方法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithNotificationCenter:(<span class="built_in">NSNotificationCenter</span> *)notificationCenter <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></td></tr></table></figure>
<ul>
<li>往队列加入通知方法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle;</div><div class="line">- (<span class="keyword">void</span>)enqueueNotification:(<span class="built_in">NSNotification</span> *)notification postingStyle:(<span class="built_in">NSPostingStyle</span>)postingStyle coalesceMask:(<span class="built_in">NSNotificationCoalescing</span>)coalesceMask forModes:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSRunLoopMode</span>&gt; *)modes;</div></pre></td></tr></table></figure>
<ul>
<li>移除队列中的通知方法:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dequeueNotificationsMatching:(<span class="built_in">NSNotification</span> *)notification coalesceMask:(<span class="built_in">NSUInteger</span>)coalesceMask;</div></pre></td></tr></table></figure>
<h3 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h3><ul>
<li><code>NSPostingStyle</code>包括三种类型：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSPostingStyle</span>) &#123;</div><div class="line">    <span class="built_in">NSPostWhenIdle</span> = <span class="number">1</span>,</div><div class="line">    <span class="built_in">NSPostASAP</span> = <span class="number">2</span>,</div><div class="line">    <span class="built_in">NSPostNow</span> = <span class="number">3</span>	 </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>NSPostWhenIdle</strong>：空闲发送通知 当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用。<br><strong>NSPostASAP</strong>：尽快发送通知 当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器。<br><strong>NSPostNow</strong> ：同步发送通知 如果不使用合并通知 和<code>postNotification:</code>一样是同步通知。</p>
<h3 id="合并通知"><a href="#合并通知" class="headerlink" title="合并通知"></a>合并通知</h3><ul>
<li><code>NSNotificationCoalescing</code>也包括三种类型：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">NSNotificationCoalescing</span>) &#123;</div><div class="line">    <span class="built_in">NSNotificationNoCoalescing</span> = <span class="number">0</span>,</div><div class="line">    <span class="built_in">NSNotificationCoalescingOnName</span> = <span class="number">1</span>,</div><div class="line">    <span class="built_in">NSNotificationCoalescingOnSender</span> = <span class="number">2</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>NSNotificationNoCoalescing</strong>：不合并通知。<br><strong>NSNotificationCoalescingOnName</strong>：合并相同名称的通知。<br><strong>NSNotificationCoalescingOnSender</strong>：合并相同通知和同一对象的通知。</p>
<ul>
<li>通过合并我们可以用来保证相同的通知只被发送一次。</li>
<li><code>forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes</code>可以使用不同的<code>NSRunLoopMode</code>配合来发送通知，可以看出实际上<code>NSNotificationQueue</code>与<code>RunLoop</code>的机制以及运行循环有关系，通过<code>NSNotificationQueue</code>队列来发送的通知和关联的<code>RunLoop</code>运行机制来进行的。</li>
</ul>
<h2 id="NSNotificatinonCenter实现原理"><a href="#NSNotificatinonCenter实现原理" class="headerlink" title="# NSNotificatinonCenter实现原理"></a># NSNotificatinonCenter实现原理</h2><ul>
<li><code>NSNotificatinonCenter</code>是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。</li>
<li><code>NSNotificatinonCenter</code>用来管理通知，将观察者注册到<code>NSNotificatinonCenter</code>的通知调度表中，然后发送通知时利用标识符<code>name</code>和<code>object</code>识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有name或者selector，可以接受参数，而且可能有返回值），如果是基于<code>block</code>创建的通知就调用<code>NSNotification</code>的<code>block</code>。</li>
</ul>
<p>### 参考资料</p>
<ul>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html#//apple_ref/doc/uid/10000043-SW1" target="_blank" rel="external">Notification Programming Topics</a></li>
<li><a href="http://www.hpique.com/2013/12/nsnotificationcenter-part-4/" target="_blank" rel="external">NSNotificationCenter part 4: Asynchronous notifications with NSNotificationQueue</a></li>
<li><a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/" target="_blank" rel="external">NSNotification &amp; NSNotification Center</a></li>
</ul>
<p>&lt;!— more –&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;#前言&quot;&gt;&lt;/a&gt;#前言&lt;/h2&gt;&lt;p&gt;Cocoa中使用NSNotification、NSNotificationCenter和KVO来实现观察者模式，实现对象间一对多的依赖关系。&lt;/p&gt;
&lt;p&gt;本篇文章主要来讨论NSNotification和NSNotificationCenter&lt;/p&gt;
&lt;h2 id=&quot;NSNotification&quot;&gt;&lt;a href=&quot;#NSNotification&quot; class=&quot;headerlink&quot; title=&quot;# NSNotification&quot;&gt;&lt;/a&gt;# NSNotification&lt;/h2&gt;&lt;p&gt;&lt;code&gt;NSNotification&lt;/code&gt;是方便&lt;code&gt;NSNotificationCenter&lt;/code&gt;广播到其他对象时的封装对象，简单讲即通知中心对通知调度表中的对象广播时发送&lt;code&gt;NSNotification&lt;/code&gt;对象。&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSNotification&lt;/span&gt; : &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; &amp;lt;&lt;span class=&quot;title&quot;&gt;NSCopying&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;NSCoding&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSNotificationName&lt;/span&gt; name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;retain&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; object;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;readonly&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;copy&lt;/span&gt;) &lt;span class=&quot;built_in&quot;&gt;NSDictionary&lt;/span&gt; *userInfo;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;NSNotification&lt;/code&gt;对象包含名称、object、字典三个属性，名称是用来标识通知的标记，object是要通知的对象可以为&lt;code&gt;nil&lt;/code&gt;,字典用来存储发送通知时附带的信息，也可以为&lt;code&gt;nil&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://github.com/VeinGuo/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>autoreleasepool是如何实现的？</title>
    <link href="https://github.com/VeinGuo/2016/12/13/autoreleasepool%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F/"/>
    <id>https://github.com/VeinGuo/2016/12/13/autoreleasepool是如何实现的？/</id>
    <published>2016-12-12T17:30:00.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然在ARC时代我们可以完全不知道<code>Autorelease</code>就能管理好内存，但在了解<code>objc</code>内存管理还是十分重要的，在阅读了书籍和一些干货并动手验证之后，决定总结<code>autoreleasePool</code>的实现。</p>
<hr>
<h2 id="什么是autorelease"><a href="#什么是autorelease" class="headerlink" title="什么是autorelease"></a>什么是autorelease</h2><p><code>autoreleasePool</code>如何实现需要先知道什么是<code>autorelease</code>？</p>
<p><code>autorelease</code>类似于C语言中<a href="https://en.wikipedia.org/wiki/Automatic_variable" target="_blank" rel="external">Automatic variable</a>自动变量，程序执行时，若某自动变量超出其作用域，该自动变量将被自动废弃。</p>
<h2 id="autorelease何时释放"><a href="#autorelease何时释放" class="headerlink" title="autorelease何时释放"></a>autorelease何时释放</h2><p>面试时提问<code>objc</code>内存管理基本都会问到<code>autorelease</code>何时释放,在没有使用<code>@autoreleasepool</code>的情况,<code>autorelease</code>对象是在当前的<code>runloop</code>迭代结束时释放。</p>
<p>每个runloop中都会创建一个 <code>autoreleasepool</code> 并在runloop迭代结束进行释放。</p>
<p>如果是手动创建<code>autoreleasepool</code>,自己创建Pool并释放：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MRC</span></div><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"></div><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];</div><div class="line"></div><div class="line"><span class="comment">// ARC</span></div><div class="line"><span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">		<span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>Apple</code>文档中提到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool blocks are more efficient than using an instance of NSAutoreleasePool directly; you can also use them even if you do not use ARC.</div></pre></td></tr></table></figure></p>
<p>不管是<code>MRC</code>还是<code>ARC</code>最好使用@autoreleasepool blocks。<br><a id="more"></a></p>
<h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h2><p>上面提到的使用<code>@autoreleasepool</code>来手动创建并释放<code>autorelease</code><br><code>@autoreleasepool</code> 使用<code>clang</code>编译之后</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/* @autoreleasepool */</span> </div><div class="line">&#123; </div><div class="line">	__AtAutoreleasePool __autoreleasepool; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>@autoreleasepool</code>被转转换成<code>__AtAutoreleasePool</code> 结构体类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __AtAutoreleasePool </div><div class="line">&#123;</div><div class="line">  __AtAutoreleasePool() </div><div class="line">  &#123;</div><div class="line">		atautoreleasepoolobj = objc_autoreleasePoolPush();</div><div class="line">  &#125;</div><div class="line">  ~__AtAutoreleasePool() </div><div class="line">  &#123;</div><div class="line">  		objc_autoreleasePoolPop(atautoreleasepoolobj);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到 <code>__AtAutoreleasePool()</code> 构造函数调用<code>objc_autoreleasePoolPush()</code>,<code>~__AtAutoreleasePool()</code> 析构函数调用 <code>objc_autoreleasePoolPop()</code></p>
<p>在 <code>MRC</code> 中我们使用 <code>NSAutoreleasePool</code> 来创建AutoreleasePool,那么相应的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">// 相当于调用构造函数也就是 objc_autoreleasePoolPush();</span></div><div class="line">[pool drain];</div><div class="line"><span class="comment">// 相当于调用析构函数也就是 objc_autoreleasePoolPop(pool);</span></div></pre></td></tr></table></figure>
<p><code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 是什么呢？</p>
<p><code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 实现需要从<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="external">runtime</a>源代码看到,文中的代码的是最新的<code>objc4-706.tar.gz</code></p>
<p>在 <code>NSObject.mm</code> 文件中：<br><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/2.png" alt="NSObject.mm"></p>
<p>实际上是调用<code>AutoreleasePoolPage</code>的<code>push</code>和<code>pop</code>两个类方法</p>
<h3 id="AutoreleasePoolPage"><a href="#AutoreleasePoolPage" class="headerlink" title="AutoreleasePoolPage"></a>AutoreleasePoolPage</h3><p>首先来看一下<code>AutoreleasePoolPage</code>这个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)</span></div><div class="line"></div><div class="line"><span class="meta">#   <span class="meta-keyword">define</span> POOL_BOUNDARY nil</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE = </div><div class="line">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);</div><div class="line"></div><div class="line">    <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;</div><div class="line">    id *next;</div><div class="line">    <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;</div><div class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</div><div class="line">    AutoreleasePoolPage *child;</div><div class="line">    <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;</div><div class="line">    <span class="keyword">uint32_t</span> hiwat;</div></pre></td></tr></table></figure>
<p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/AutoreleasePoolPage.png" alt="AutoreleasePoolPage"></p>
<ul>
<li><code>magic</code> 检查校验完整性的变量</li>
<li><code>next</code>  指向新加入的autrelease对象下一个位置如下图：</li>
</ul>
<p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/next.png" alt="next"></p>
<ul>
<li><code>thread</code> page当前所在的线程</li>
<li><code>parent</code>    父节点 指向前一个page</li>
<li><code>child</code>    子节点 指向下一个page</li>
<li><code>depth</code> 链表的深度，节点个数</li>
<li><p><code>hiwat</code> high water mark 数据容纳的一个上限</p>
</li>
<li><p><code>EMPTY_POOL_PLACEHOLDER</code> 空池占位</p>
</li>
<li><p><code>POOL_BOUNDARY</code> 是一个边界对象 <code>nil</code>,之前的源代码变量名是 <code>POOL_SENTINEL</code>哨兵对象,用来区别每个<code>page</code>即每个 <code>AutoreleasePoolPage</code> 边界</p>
</li>
<li><p><code>PAGE_MAX_SIZE</code> 定义的大小在下图可以看到:</p>
</li>
</ul>
<p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/PAGE_MAX_SIZE.png" alt="PAGE_MAX_SIZE"></p>
<ul>
<li><code>PAGE_MAX_SIZE</code> = 4096, 为什么是4096呢？其实就是虚拟内存每个扇区4096个字节,<a href="https://zh.wikipedia.org/zh-hans/4K%E5%AF%B9%E9%BD%90" target="_blank" rel="external">4K对齐</a>的说法。</li>
<li><code>COUNT</code> 一个<code>page</code>里对象数</li>
</ul>
<p><strong>在自动释放池中每一个<code>AutoreleasePoolPage</code>都是以双链表的形式连接起来的：</strong></p>
<p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/Pool.png" alt="Pool"></p>
<p><strong><code>parent</code> 指向前一个 <code>page</code> , <code>child</code> 指向下一个 <code>page</code></strong></p>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/push.png" alt="PUSH"><br>每当自动释放池调用<code>objc_autoreleasePoolPush</code>时都会把边界对象放进栈顶,然后返回边界对象,用于释放。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">atautoreleasepoolobj = objc_autoreleasePoolPush();</div></pre></td></tr></table></figure></p>
<p><code>atautoreleasepoolobj</code> 就是返回的边界对象</p>
<p><code>push</code>就是压栈的操作,先加入边界对象然后添加A对象在边界对象之后,下一个B对象压入A对象之后,就像羽毛球筒放羽毛球一样</p>
<h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p><img src="http://ojaltanzc.bkt.clouddn.com/2016-12-13-aotureleasepool/pop.png" alt="POP"><br>自动释放池释放是传入 <code>push</code> 返回的边界对象,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_autoreleasePoolPop(atautoreleasepoolobj);</div></pre></td></tr></table></figure>
<p>然后将边界对象指向的这一页 <code>AutoreleasePoolPage</code> 内的对象释放</p>
<h2 id="End"><a href="#End" class="headerlink" title="@End"></a>@End</h2><p> <strong>总结：</strong></p>
<ol>
<li>自动释放池是一个个 <code>AutoreleasePoolPage</code> 组成的一个<code>page</code>是4096字节大小,每个 <code>AutoreleasePoolPage</code> 以双向链表连接起来形成一个自动释放池</li>
<li><code>pop</code> 时是传入边界对象,然后对<code>page</code> 中的对象发送<code>release</code> 的消息</li>
</ol>
<p>文章有什么理解不是很到位的希望指出</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">《objc高级编程:iOS与OS X多线程和内存管理》</a></li>
<li><a href="http://draveness.me/autoreleasepool/" target="_blank" rel="external">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></li>
<li><a href="https://developer.apple.com/reference/foundation/nsautoreleasepool#//apple_ref/occ/cl/NSAutoreleasePool" target="_blank" rel="external">NSAutoreleasePool</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
</ul>
<p>&lt;!— more –&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然在ARC时代我们可以完全不知道&lt;code&gt;Autorelease&lt;/code&gt;就能管理好内存，但在了解&lt;code&gt;objc&lt;/code&gt;内存管理还是十分重要的，在阅读了书籍和一些干货并动手验证之后，决定总结&lt;code&gt;autoreleasePool&lt;/code&gt;的实现。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;什么是autorelease&quot;&gt;&lt;a href=&quot;#什么是autorelease&quot; class=&quot;headerlink&quot; title=&quot;什么是autorelease&quot;&gt;&lt;/a&gt;什么是autorelease&lt;/h2&gt;&lt;p&gt;&lt;code&gt;autoreleasePool&lt;/code&gt;如何实现需要先知道什么是&lt;code&gt;autorelease&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;autorelease&lt;/code&gt;类似于C语言中&lt;a href=&quot;https://en.wikipedia.org/wiki/Automatic_variable&quot;&gt;Automatic variable&lt;/a&gt;自动变量，程序执行时，若某自动变量超出其作用域，该自动变量将被自动废弃。&lt;/p&gt;
&lt;h2 id=&quot;autorelease何时释放&quot;&gt;&lt;a href=&quot;#autorelease何时释放&quot; class=&quot;headerlink&quot; title=&quot;autorelease何时释放&quot;&gt;&lt;/a&gt;autorelease何时释放&lt;/h2&gt;&lt;p&gt;面试时提问&lt;code&gt;objc&lt;/code&gt;内存管理基本都会问到&lt;code&gt;autorelease&lt;/code&gt;何时释放,在没有使用&lt;code&gt;@autoreleasepool&lt;/code&gt;的情况,&lt;code&gt;autorelease&lt;/code&gt;对象是在当前的&lt;code&gt;runloop&lt;/code&gt;迭代结束时释放。&lt;/p&gt;
&lt;p&gt;每个runloop中都会创建一个 &lt;code&gt;autoreleasepool&lt;/code&gt; 并在runloop迭代结束进行释放。&lt;/p&gt;
&lt;p&gt;如果是手动创建&lt;code&gt;autoreleasepool&lt;/code&gt;,自己创建Pool并释放：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// MRC&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt; *pool = [&lt;span class=&quot;built_in&quot;&gt;NSAutoreleasePool&lt;/span&gt; alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[obj autorelease];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[pool drain];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ARC&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; obj = [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; alloc] init];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;Apple&lt;/code&gt;文档中提到：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;@autoreleasepool blocks are more efficient than using an instance of NSAutoreleasePool directly; you can also use them even if you do not use ARC.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;不管是&lt;code&gt;MRC&lt;/code&gt;还是&lt;code&gt;ARC&lt;/code&gt;最好使用@autoreleasepool blocks。&lt;br&gt;
    
    </summary>
    
    
      <category term="objc" scheme="https://github.com/VeinGuo/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>Learn Swift</title>
    <link href="https://github.com/VeinGuo/2016/12/10/Learn%20Swift/"/>
    <id>https://github.com/VeinGuo/2016/12/10/Learn Swift/</id>
    <published>2016-12-10T00:30:00.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>学习Swift的笔记将放在 <code>github</code> 上<br>地址：👇</p>
<ul>
<li><a href="https://github.com/VeinGuo/StudySwift/wiki">Swift Note</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动&quot;&gt;&lt;a href=&quot;#移动&quot; class=&quot;headerlink&quot; title=&quot;移动&quot;&gt;&lt;/a&gt;移动&lt;/h2&gt;&lt;p&gt;学习Swift的笔记将放在 &lt;code&gt;github&lt;/code&gt; 上&lt;br&gt;地址：👇&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;htt
    
    </summary>
    
    
      <category term="Learn Swift" scheme="https://github.com/VeinGuo/tags/Learn-Swift/"/>
    
  </entry>
  
  <entry>
    <title>Block是如何实现？</title>
    <link href="https://github.com/VeinGuo/2016/12/07/Block%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/"/>
    <id>https://github.com/VeinGuo/2016/12/07/Block是如何实现？/</id>
    <published>2016-12-07T00:50:00.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章是阅读<a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">《Objective-C高级编程:iOS与OS X多线程和内存管理》</a>之后的一些理解总结。</p>
<hr>
<p>理解Block如何实现,需要了解</p>
<ul>
<li>什么是<code>Block</code>?</li>
<li><code>Block</code>的语法</li>
</ul>
<h2 id="什么是Block"><a href="#什么是Block" class="headerlink" title="什么是Block"></a>什么是Block</h2><p><code>Block</code>是<code>C</code>语言的拓展功能。在Apple文档中有一句话说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In other languages and environments, a block object is sometimes also called a closure or a lambda.</div></pre></td></tr></table></figure>
<p>其他语言和环境，一个<code>block</code>对象有时候也被称作<code>closure</code>闭包或<code>^</code>;</p>
<p>在阮一峰的<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">学习Javascript闭包（Closure）</a>中解释了什么是闭包。</p>
<p><strong>闭包就是能够读取其他函数内部变量的函数。</strong><br><a id="more"></a></p>
<h2 id="Block的语法"><a href="#Block的语法" class="headerlink" title="Block的语法"></a>Block的语法</h2><p>声明一个<code>Block</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSUInteger (^lengthBlock)(NSString *);</div></pre></td></tr></table></figure>
<ol>
<li><code>NSUInteger</code>是<code>Block</code>返回的值类型</li>
<li><code>^lengthBlock</code>表示声明了名字<code>lengthBlock</code>的<code>Block</code></li>
<li><code>NSString *</code>表示<code>NSString</code>类型的参数</li>
</ol>
<p>创建一个<code>Block</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lengthBlock = ^(<span class="built_in">NSString</span> *str) &#123;</div><div class="line">        <span class="keyword">return</span> str.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)lengthBlock(<span class="string">@"123"</span>)); <span class="comment">// console 3</span></div></pre></td></tr></table></figure>
<ol>
<li><code>^(NSString *str)</code>对<code>lengthBlock</code>的定义,分配给<code>lengthBlock</code>的值</li>
<li><code>str</code>参数名称</li>
<li><code>{...}</code>大括弧是<code>Block</code>的主体</li>
<li><code>return str.length</code>是<code>lengthBlock</code>的返回值</li>
</ol>
<p><strong><code>Block</code>可以直接使用相同的作用域内定义的变量</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = <span class="string">@"123"</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSUInteger</span> (^lengthBlock)(<span class="built_in">NSString</span> *) = ^(<span class="built_in">NSString</span> *str)&#123;</div><div class="line">        <span class="keyword">return</span> string.length + str.length;</div><div class="line">    &#125;;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span>)lengthBlock(<span class="string">@"456"</span>)); <span class="comment">// console 6</span></div></pre></td></tr></table></figure>
<p><strong>Block类型变量</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)stringWithLengthBlock:(<span class="built_in">NSUInteger</span> (^)(<span class="built_in">NSString</span> *))lengthBlock&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu"</span>,lengthBlock(<span class="string">@"456"</span>)); <span class="comment">// console 6</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">[<span class="keyword">self</span> stringWithLengthBlock:^<span class="built_in">NSUInteger</span>(<span class="built_in">NSString</span> *str) &#123;</div><div class="line">        <span class="built_in">NSString</span> *string = <span class="string">@"123"</span>;</div><div class="line">        <span class="keyword">return</span> string.length + str.length;</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>也可以使用<code>typedef</code>声明</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)(<span class="built_in">NSString</span> *str);</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)stringWithLengthBlock:(Block)block&#123;</div><div class="line">    block(<span class="string">@"123"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Block的实现"><a href="#Block的实现" class="headerlink" title="Block的实现"></a>Block的实现</h2><p>举个🌰</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;printf(<span class="string">"Block\n"</span>);&#125;;</div><div class="line">    block();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用clang使用编译器改写文件</p>
<blockquote>
<p>这里需要注意的是编译后的代码只是为了理解Block的实现,并不是Block的源码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc 文件名</div></pre></td></tr></table></figure>
<p>下面转换例子代码后<code>Block</code>的相关代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Block\n"</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)</div><div class="line">   ())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">   </div><div class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到第一个<code>__main_block_impl_0</code>结构体包含<code>__block_impl</code>和<code>__main_block_desc_0</code>两个结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们来看一下Block结构体的构成</p>
<ol>
<li><code>isa</code>指针,用于指向Block的指针</li>
<li><code>Flags</code> 表示Block附加的信息</li>
<li><code>Reserved</code> 保留变量</li>
<li><code>FuncPtr</code> 函数指针指向Block实现的函数地址</li>
</ol>
<p>其中<code>isa</code>指向Block有三种类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isa = &amp;_NSConcreteStackBlock;</div><div class="line">isa = &amp;_NSConcreteGlobalBlock;</div><div class="line">isa = &amp;_NSConcreteMallocBlock;</div></pre></td></tr></table></figure>
<p><code>__main_block_desc_0</code>的构成,用来描述Block一些信息<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  <span class="keyword">size_t</span> reserved;</div><div class="line">  <span class="keyword">size_t</span> Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure></p>
<ol>
<li><code>reserved</code>    保留变量</li>
<li><code>Block_size</code>    Block的大小</li>
</ol>
<p>下面看一下初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">impl.isa = &amp;_NSConcreteStackBlock;</div></pre></td></tr></table></figure>
<p><code>_NSConcreteStackBlock</code> 用来初始化了<code>__block_impl</code>结构体的<code>isa</code>这里为什么使用<code>_NSConcreteStackBlock</code>来初始化,说明<code>Block</code>创建在<code>Stack</code>上</p>
<p>接下来看 <code>int main{}</code>中的调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));   </div><div class="line">   </div><div class="line"><span class="comment">// 分成两部分</span></div><div class="line"></div><div class="line"><span class="comment">// 第一部分</span></div><div class="line">&amp;__main_block_impl_0 ((<span class="keyword">void</span> *) __main_block_func_0, &amp;__main_block_desc_0_DATA)</div><div class="line"></div><div class="line"><span class="comment">// 去掉转换部分</span></div><div class="line">__main_block_impl_0 impl = (__main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA));</div><div class="line"></div><div class="line"><span class="comment">// 第二部分</span></div><div class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) =((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0()</div><div class="line"><span class="comment">// 去掉转换部分</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 *block = &amp;impl;  <span class="comment">// 这里impl指的是上面的第一部分</span></div></pre></td></tr></table></figure>
<p>将<code>__main_block_impl_0</code>结构的<code>impl</code>实例地址赋值给<code>*block</code>函数指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line"></div><div class="line"><span class="comment">// 去掉转换部分</span></div><div class="line">(*block -&gt;impl.FuncPtr)(block);</div></pre></td></tr></table></figure>
<p>代码使用了<a href="http://baike.baidu.com/link?url=2XOSKIcmha-ntPSox2Rl0mee7lMaJwatpwWzwqvOjU5DAnsEiX8rAXJBTcccpQ9U2EFLDae8YAzSrPnXLONqiiR1vIllvLPvesp-bM1oubRK2y1uFu-2ueudqZDcT1qv#2" target="_blank" rel="external">函数指针</a>调用函数<br>取出<code>block</code>的函数指针调用<code>FuncPtr</code>,以自身（<code>block</code>）为参数传入</p>
<h3 id="总结一下Block简单的实现流程"><a href="#总结一下Block简单的实现流程" class="headerlink" title="总结一下Block简单的实现流程"></a><strong>总结一下<code>Block</code>简单的实现流程</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">			main();</div><div class="line">			  ⬇︎</div><div class="line">**初始化__main_block_impl_0 结构体**</div><div class="line">			  ⬇︎</div><div class="line">**将结构体地址赋值给*block函数指针**</div><div class="line">			  ⬇︎</div><div class="line">**调用block函数指针的FuncPtr函数**</div><div class="line">			  ⬇︎</div><div class="line">			**结束**</div></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p> <code>Block</code>还有截获自动变量、__block修饰符、block存储域即上文提到的三种block类型，内存管理等等问题待我细细研习之后再写总结。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">《Objective-C高级编程:iOS与OS X多线程和内存管理》</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">学习Javascript闭包(Closure)</a></li>
<li><a href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html" target="_blank" rel="external">对Objective-C中Block的追探</a></li>
</ul>
<p>&lt;!— more –&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;文章是阅读&lt;a href=&quot;https://book.douban.com/subject/24720270/&quot;&gt;《Objective-C高级编程:iOS与OS X多线程和内存管理》&lt;/a&gt;之后的一些理解总结。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;理解Block如何实现,需要了解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是&lt;code&gt;Block&lt;/code&gt;?&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Block&lt;/code&gt;的语法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;什么是Block&quot;&gt;&lt;a href=&quot;#什么是Block&quot; class=&quot;headerlink&quot; title=&quot;什么是Block&quot;&gt;&lt;/a&gt;什么是Block&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Block&lt;/code&gt;是&lt;code&gt;C&lt;/code&gt;语言的拓展功能。在Apple文档中有一句话说明：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;In other languages and environments, a block object is sometimes also called a closure or a lambda.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其他语言和环境，一个&lt;code&gt;block&lt;/code&gt;对象有时候也被称作&lt;code&gt;closure&lt;/code&gt;闭包或&lt;code&gt;^&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;在阮一峰的&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot;&gt;学习Javascript闭包（Closure）&lt;/a&gt;中解释了什么是闭包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包就是能够读取其他函数内部变量的函数。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://github.com/VeinGuo/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>iOS常用数据持久化</title>
    <link href="https://github.com/VeinGuo/2016/11/28/iOS%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://github.com/VeinGuo/2016/11/28/iOS常用数据持久化/</id>
    <published>2016-11-28T07:47:00.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据层一直是程序的核心结构之一，在iOS开发过程中通常需要对数据进行持久化缓存以保证在无网络情况下打开App后进行一些展示或缓存聊天记录等，这时候就需要持久化数据。</p>
<h2 id="什么是数据持久化"><a href="#什么是数据持久化" class="headerlink" title="什么是数据持久化"></a>什么是数据持久化</h2><p>数据持久化就是将内存中的数据模型转换为存储模型,以及将存储模型转换为内存中的数据模型的统称. 数据模型可以是任何数据结构或对象模型,存储模型可以是关系模型、XML、二进制流等。cmp和Hibernate只是对象模型到关系模型之间转换的不同实现。</p>
<h2 id="常用的数据持久化"><a href="#常用的数据持久化" class="headerlink" title="常用的数据持久化"></a>常用的数据持久化</h2><p>在项目开发中我最常使用的持久化方式有：</p>
<ul>
<li>NSUserDefault</li>
<li>Plist文件存储 </li>
<li>NSKeyedArchiver 归档</li>
<li>SQLite3(数据库)</li>
</ul>
<a id="more"></a>
<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><p>Plist 和 归档 使用文件操作存储需要用到NSFileManager，创建一个工具类来对App的文件进行</p>
<p>NSFileManager 是处理文件系统的 Foundation 框架的高级API。它抽象了 Unix 和 Finder 的内部构成，和 iCloud ubiquitous containers 一样， 提供了创建，读取，移动，拷贝以及删除本地或者网络驱动器上的文件或者目录的方法。</p>
<p>NSFileManager 是一个单例使用以下方法来获得</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> + (<span class="built_in">NSFileManager</span> *)defaultManager</div></pre></td></tr></table></figure>
<p>NSFileManager常用方法就不多提了这里需要提的一点是线程注意。<br>apple 中提到：</p>
<h4 id="Threading-Considerations"><a href="#Threading-Considerations" class="headerlink" title="Threading Considerations"></a>Threading Considerations</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The methods of the shared NSFileManager object can be called from multiple threads safely. However, if you use a delegate to receive notifications about the status of move, copy, remove, and link operations, you should create a unique instance of the file manager object, assign your delegate to that object, and use that file manager to initiate your operations.</div></pre></td></tr></table></figure>
<p>大概说一下意思就是共享的NSFileManager对象方法可以从多个线程调用是安全的。可是，如果使用委托通知的状态移动，复制，删除等等操作，应该创建一个唯一实例并使用该实例来开始你的操作。</p>
<p>如使用NSFileManagerDelegate时最好创建实例来进行操作</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSFileManager</span> *fileManager = [[<span class="built_in">NSFileManager</span> alloc] init];</div><div class="line">fileManager.delegate = delegate;</div><div class="line"></div><div class="line"><span class="built_in">NSURL</span> *bundleURL = [[<span class="built_in">NSBundle</span> mainBundle] bundleURL];</div><div class="line"><span class="built_in">NSArray</span> *contents = [fileManager contentsOfDirectoryAtURL:bundleURL</div><div class="line">                               includingPropertiesForKeys:@[]</div><div class="line">                               options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span> </div><div class="line">                               error:<span class="literal">nil</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *filePath <span class="keyword">in</span> contents) &#123;</div><div class="line">    [fileManager removeItemAtPath:filePath error:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是我开发中一些常用的文件操作方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个存储文件夹并获取路径</span></div><div class="line">+ (<span class="built_in">NSString</span> *)getDocumentPath</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *documentPath = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        <span class="built_in">NSArray</span> *paths = <span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>);</div><div class="line">        documentPath = [[<span class="built_in">NSString</span> alloc]initWithFormat:<span class="string">@"%@/%@/"</span>,[paths objectAtIndex:<span class="number">0</span>],FOLDER_FILE_NAME];</div><div class="line">        <span class="keyword">if</span> (![[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:documentPath])</div><div class="line">        &#123;</div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] createDirectoryAtPath:documentPath</div><div class="line">                                      withIntermediateDirectories:<span class="literal">NO</span></div><div class="line">                                                       attributes:<span class="literal">nil</span></div><div class="line">                                                            error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> documentPath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 文件大小</span></div><div class="line">+ (<span class="built_in">NSUInteger</span>)getFileSizeAtFileName:(<span class="built_in">NSString</span>*)fileName&#123;</div><div class="line">  <span class="built_in">NSString</span> *path = [[VGFileManagerCommon getDocumentPath] stringByAppendingPathComponent:fileName];</div><div class="line">    <span class="keyword">return</span> [[[<span class="built_in">NSFileManager</span> defaultManager] attributesOfItemAtPath:path error:<span class="literal">nil</span>]fileSize];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 文件是否存在</span></div><div class="line">+ (<span class="built_in">BOOL</span>)isFileExistAtPath:(<span class="built_in">NSString</span>*)filePath</div><div class="line">&#123;</div><div class="line">    <span class="built_in">BOOL</span> isExist = <span class="literal">NO</span>;</div><div class="line">    isExist = [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:filePath];</div><div class="line">    <span class="keyword">return</span> isExist;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 文件是否存在</span></div><div class="line">+ (<span class="built_in">BOOL</span>)isFileExistAtFileName:(<span class="built_in">NSString</span>*)fileName</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *path = [[VGFileManagerCommon getDocumentPath] stringByAppendingPathComponent:fileName];</div><div class="line">    <span class="keyword">return</span> [VGFileManagerCommon isFileExistAtPath:path];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 删除文件</span></div><div class="line">+ (<span class="built_in">BOOL</span>)deleteFileAtFileName:(<span class="built_in">NSString</span> *)fileName</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSFileManager</span>   *fileMgr = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="built_in">NSString</span> *deletePath = [[VGFileManagerCommon getDocumentPath] stringByAppendingPathComponent:fileName];</div><div class="line">    <span class="built_in">NSError</span> *err = <span class="literal">nil</span>;</div><div class="line">    [fileMgr removeItemAtPath:deletePath error:&amp;err];</div><div class="line">    <span class="keyword">return</span> err != <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NSUserDefault"><a href="#NSUserDefault" class="headerlink" title="NSUserDefault"></a>NSUserDefault</h3><p>常用来存储一个简单的状态如是否第一次登陆</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSUserDefaults</span> *userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];</div><div class="line">[userDefaults setBool:<span class="literal">YES</span> forKey:<span class="string">@"firstLogin"</span>];</div><div class="line">[userDefaults synchronize];</div></pre></td></tr></table></figure>
<h3 id="Plist文件存储"><a href="#Plist文件存储" class="headerlink" title="Plist文件存储"></a>Plist文件存储</h3><p>Property List，属性列表文件，它是一种用来存储串行化后的对象的文件。属性列表文件的扩展名为.plist ，plist文件的实质为XML文件。</p>
<p>可以被序列化的类型只有如下几种：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> </div><div class="line"><span class="built_in">NSMutableArray</span></div><div class="line"><span class="built_in">NSDictionary</span> </div><div class="line"><span class="built_in">NSMutableDictionary</span></div><div class="line"><span class="built_in">NSData</span> </div><div class="line"><span class="built_in">NSMutableData</span></div><div class="line"><span class="built_in">NSString</span> </div><div class="line"><span class="built_in">NSMutableString</span></div><div class="line"><span class="built_in">NSNumber</span></div><div class="line"><span class="built_in">NSDate</span></div></pre></td></tr></table></figure>
<p>在实际的开发中我一般存储NSArray和NSDictonary<br>经过使用后建议使用JSON 存储 取出后转成模型，避免增减字段的问题</p>
<p>开发中例子</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)fetchItemsWithCompletion:(VGPlistStoreFetchCompletionHandler)completion&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *cacheJson = [<span class="keyword">self</span> loadCache];</div><div class="line">    <span class="keyword">if</span> (completion) &#123;</div><div class="line">        completion(cacheJson);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSDictionary</span> *)loadCache</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> savePath];</div><div class="line">    <span class="keyword">if</span> ([VGFileManagerCommon isFileExistAtPath:path]) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithContentsOfFile:path];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)savePath</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[VGFileManagerCommon getDocumentPath] stringByAppendingPathComponent:<span class="string">@"cache.plist"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)saveJSON:(<span class="built_in">NSDictionary</span> *)json</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (json) &#123;</div><div class="line">        <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> savePath];</div><div class="line">        [json writeToFile:path atomically:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NSKeyedArchiver-归档"><a href="#NSKeyedArchiver-归档" class="headerlink" title="NSKeyedArchiver 归档"></a>NSKeyedArchiver 归档</h3><p>归档只要遵循了NSCoding协议的对象都可以通过它实现序列化。<br>平时项目中使用Mantle 来实现model层 Mantle已经实现了NSCoding协议</p>
<p>Demo中例子直接存储model 但建议还是把Model转换成JSON Dictionary 来存储load时再转换成model</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)store</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)fetchItemsWithCompletion:(VGKeyedArchiverStoreFetchCompletionHandler)completion</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([VGFileManagerCommon isFileExistAtPath:[<span class="keyword">self</span> savePath]]) &#123;</div><div class="line">        VGCacheModel *model = [<span class="keyword">self</span> loadModel];</div><div class="line">        completion(model);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (VGCacheModel *)loadModel</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:[<span class="keyword">self</span> savePath]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)savePath</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *path = <span class="string">@"keyedArchiverStore.bin"</span>;</div><div class="line">    <span class="keyword">return</span> [[VGFileManagerCommon getDocumentPath] stringByAppendingPathComponent:path];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)saveModel:(VGCacheModel *)Model</div><div class="line">&#123;</div><div class="line">    <span class="built_in">BOOL</span> success = [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:Model toFile:[<span class="keyword">self</span> savePath]];</div><div class="line">    <span class="keyword">if</span> (!success) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Save Failed"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SQLite3-数据库"><a href="#SQLite3-数据库" class="headerlink" title="SQLite3(数据库)"></a>SQLite3(数据库)</h3><p>一般用来存储大量的内容并可单一的修改更新某一条缓存信息等。实际上SQLite是无类型的。即不管你在创表时指定的字段类型是什么，存储是依然可以存储任意类型的数据。而且在创表时也可以不指定字段类型。</p>
<p>开发中我一般使用FMDB第三方库来进行数据库操作，demo中例子就使用FMDB实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建数据库</span></div><div class="line">- (<span class="keyword">void</span>)openDatabase</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *filepath = [[VGFileManagerCommon getDocumentPath] stringByAppendingString:<span class="string">@"cache.db"</span>];</div><div class="line">    FMDatabase *db = [FMDatabase databaseWithPath:filepath];</div><div class="line">    <span class="keyword">if</span> ([db open])</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">self</span>.db = db;</div><div class="line">        <span class="built_in">NSString</span> *sql = <span class="string">@"CREATE TABLE IF NOT EXISTS CACHE \</span></div><div class="line">        (uid INTEGER PRIMARY KEY, \</div><div class="line">        url TEXT, \</div><div class="line">        title TEXT)";</div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.db executeUpdate:sql])</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"execute sql %@ error %@"</span>,sql,<span class="keyword">self</span>.db.lastError);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"open database failed %@"</span>,filepath);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - public</span></div><div class="line"></div><div class="line">- (<span class="built_in">NSArray</span> &lt;VGCacheModel *&gt;*)fetchCacheModelWithLimit:(<span class="built_in">NSInteger</span>)limit&#123;</div><div class="line">    __block <span class="built_in">NSArray</span> *result = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span> *sql = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (limit) &#123;</div><div class="line">        sql = <span class="string">@"SELECT *FROM CACHE ORDER BY uid DESC LIMIT ?"</span>;</div><div class="line">    &#125;</div><div class="line">    db_sync_safe(^&#123;</div><div class="line">        <span class="built_in">NSMutableArray</span> &lt;VGCacheModel *&gt;*array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        FMResultSet *rs = [<span class="keyword">self</span>.db executeQuery:sql, @(limit)];</div><div class="line">        <span class="keyword">while</span> ([rs next]) &#123;</div><div class="line">            VGCacheModel *model = loadToDatabase(rs);</div><div class="line">            [array addObject:model];</div><div class="line">        &#125;</div><div class="line">        [rs close];</div><div class="line">        result = array;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)saveModels:(<span class="built_in">NSArray</span> &lt;VGCacheModel *&gt;*)models&#123;</div><div class="line">    db_sync_safe(^&#123;</div><div class="line">        <span class="keyword">if</span> ([models count]) &#123;</div><div class="line">            [<span class="keyword">self</span>.db beginTransaction];</div><div class="line">            <span class="keyword">for</span> (VGCacheModel*model <span class="keyword">in</span> models) &#123;</div><div class="line">                saveToDatabase(<span class="keyword">self</span>.db, model);</div><div class="line">            &#125;</div><div class="line">            [<span class="keyword">self</span>.db commit];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)updateModel:(VGCacheModel *)model&#123;</div><div class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@"UPDATE CACHE SET TITLE = ? WHRER uid = ?"</span>;</div><div class="line">    db_async(^&#123;</div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.db executeUpdate:sql, model.title, model.uid]) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"update failed sql %@"</span>,sql);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - save &amp; load</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> VGCacheModel * loadToDatabase(FMResultSet *resultSet)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSInteger</span> uid = [resultSet longLongIntForColumn:<span class="string">@"uid"</span>];</div><div class="line">    <span class="built_in">NSString</span> *URL = [resultSet stringForColumn:<span class="string">@"url"</span>];</div><div class="line">    <span class="built_in">NSString</span> *title = [resultSet stringForColumn:<span class="string">@"title"</span>];</div><div class="line">    </div><div class="line">    VGCacheModel *model = [[VGCacheModel alloc] init];</div><div class="line">    model.uid = uid;</div><div class="line">    model.imageURL = URL;</div><div class="line">    model.title = title;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> model;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> saveToDatabase(FMDatabase *db, VGCacheModel *model)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@"INSERT OR REPLACE INTO CACHE(uid, url, title) VALUES(?,?,?)"</span>;</div><div class="line">    <span class="keyword">if</span>(![db executeUpdate:sql,</div><div class="line">        @(model.uid),</div><div class="line">        model.imageURL,</div><div class="line">        model.title])&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"update failed sql %@"</span>,sql);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Queue</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> cacheDatabaseQueue()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> queue;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        queue = dispatch_queue_create(databaseQueue, <span class="number">0</span>);</div><div class="line">        dispatch_queue_set_specific(queue, kDatabaseQueueSpecificKey, (<span class="keyword">void</span> *)kDatabaseQueueSpecificKey, <span class="literal">NULL</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> queue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^dispatch_block)(<span class="keyword">void</span>);</div><div class="line"><span class="keyword">void</span> db_sync_safe(dispatch_block block)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (dispatch_get_specific(kDatabaseQueueSpecificKey))</div><div class="line">    &#123;</div><div class="line">        block();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">dispatch_sync</span>(cacheDatabaseQueue(), ^() &#123;</div><div class="line">            block();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> db_async(dispatch_block block)&#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(cacheDatabaseQueue(), ^() &#123;</div><div class="line">        block();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>文章中例子的完整代码<br>Demo简单的实现了Plist、NSKeyedArchiver 归档、SQLite3(数据库) 三种数据持久化<br><a href="https://github.com/VeinGuo/VGCacheDemo.git">VGCacheDemo</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://nshipster.com/nsfilemanager/" target="_blank" rel="external">NSHipster NSFileManager</a></li>
<li><a href="http://www.jianshu.com/p/119fb5bdf30a" target="_blank" rel="external">iOS中的数据持久化</a></li>
<li><a href="http://www.jianshu.com/p/7616cbd72845" target="_blank" rel="external">我要永远地记住你！(iOS中几种数据持久化方案)</a></li>
</ul>
<p>&lt;!— more –&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据层一直是程序的核心结构之一，在iOS开发过程中通常需要对数据进行持久化缓存以保证在无网络情况下打开App后进行一些展示或缓存聊天记录等，这时候就需要持久化数据。&lt;/p&gt;
&lt;h2 id=&quot;什么是数据持久化&quot;&gt;&lt;a href=&quot;#什么是数据持久化&quot; class=&quot;headerlink&quot; title=&quot;什么是数据持久化&quot;&gt;&lt;/a&gt;什么是数据持久化&lt;/h2&gt;&lt;p&gt;数据持久化就是将内存中的数据模型转换为存储模型,以及将存储模型转换为内存中的数据模型的统称. 数据模型可以是任何数据结构或对象模型,存储模型可以是关系模型、XML、二进制流等。cmp和Hibernate只是对象模型到关系模型之间转换的不同实现。&lt;/p&gt;
&lt;h2 id=&quot;常用的数据持久化&quot;&gt;&lt;a href=&quot;#常用的数据持久化&quot; class=&quot;headerlink&quot; title=&quot;常用的数据持久化&quot;&gt;&lt;/a&gt;常用的数据持久化&lt;/h2&gt;&lt;p&gt;在项目开发中我最常使用的持久化方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSUserDefault&lt;/li&gt;
&lt;li&gt;Plist文件存储 &lt;/li&gt;
&lt;li&gt;NSKeyedArchiver 归档&lt;/li&gt;
&lt;li&gt;SQLite3(数据库)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="https://github.com/VeinGuo/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Learn Swift - 2 (Tuple)</title>
    <link href="https://github.com/VeinGuo/2016/09/29/Learn%20Swift%20-%202%20Tuple(%E5%85%83%E7%BB%84)/"/>
    <id>https://github.com/VeinGuo/2016/09/29/Learn Swift - 2 Tuple(元组)/</id>
    <published>2016-09-29T07:52:00.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple(元组)"></a>Tuple(元组)</h3><blockquote>
<p>&nbsp; Tuples group multiple values into a single compound value. The values within a tuple can be of any type and do not have to be of the same type as each other.<br>&nbsp; 元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>
</blockquote>
<hr>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = (<span class="string">"Vein"</span>, <span class="number">66</span>)</div></pre></td></tr></table></figure>
<p>&nbsp; 上面这个例子中，<code>（“Vein”, 66）</code> 是一个人的姓名和体重的元组。<br><code>(&quot;Vein&quot;, 66)</code> 元组把一个<code>String</code> 和一个<code>Int</code> 两个不同的类型组合起来。</p>
<p>你也可以随意组合不同类型如：（<code>Int</code>, <code>Int</code>, <code>Double</code>、(<code>String</code>, <code>Bool</code>)或者（<code>String</code>, <code>String</code>, <code>String</code>)等等其他任何你想组合的元组。</p>
<a id="more"></a>
<h5 id="分解（decompose）"><a href="#分解（decompose）" class="headerlink" title="分解（decompose）"></a>分解（decompose）</h5><p>你可以分解元组的内容，变成单独的常量和变量，然后你可以拿来直接使用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> (name, weight) = person</div><div class="line"><span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">\(name)</span>"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"体重:<span class="subst">\(weight)</span>"</span>)</div></pre></td></tr></table></figure>
<p>过滤掉某一部分的话可以使用<code>（_, weight）</code>的方法，这样只取出元组中的weight:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (<span class="number">_</span> ,weight) = person</div><div class="line"><span class="built_in">print</span>(<span class="string">"体重:<span class="subst">\(weight)</span>"</span>)</div></pre></td></tr></table></figure>
<p>你也可以像取数组中元素一样，使用下标获取元组中的元素，下标从<code>0</code>开始：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">\(person.<span class="number">0</span>)</span>"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"体重:<span class="subst">\(person.<span class="number">1</span>)</span>"</span>)</div></pre></td></tr></table></figure>
<p>当然你也可以在定义元组时就对单个元素命名并用命名来获取这些元素的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = (name: <span class="string">"Vein"</span>, weight: <span class="number">66</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"姓名:<span class="subst">\(person.name)</span>"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"体重:<span class="subst">\(person.weight)</span>"</span>)</div></pre></td></tr></table></figure>
<h4 id="元组实际的应用例子"><a href="#元组实际的应用例子" class="headerlink" title="元组实际的应用例子"></a>元组实际的应用例子</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxValueAndMinValue</span> <span class="params">( values:[Int] )</span></span> -&gt; (<span class="built_in">max</span>:<span class="type">Int</span>, <span class="built_in">min</span>:<span class="type">Int</span>)    &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> maxValue = values[<span class="number">0</span>]</div><div class="line">    <span class="keyword">var</span> minValue = values[<span class="number">0</span>]</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> values</div><div class="line">    &#123;</div><div class="line">        maxValue = <span class="built_in">max</span>(maxValue, value)</div><div class="line">        minValue = <span class="built_in">min</span>(minValue, value)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> (maxValue, minValue)</div><div class="line">&#125;</div><div class="line">maxValueAndMinValue(values: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</div></pre></td></tr></table></figure>
<p>上面这个函数使用元组返回两个值，一个<code>max</code>和一个<code>min</code></p>
<blockquote>
<p>&nbsp; Tuples are particularly useful as the return values of functions. A function that tries to retrieve a web page might return the (Int, String) tuple type to describe the success or failure of the page retrieval. By returning a tuple with two distinct values, each of a different type, the function provides more useful information about its outcome than if it could only return a single value of a single type. For more information, see Functions with Multiple Return Values.<br>&nbsp; 作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 (Int, String) 元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考函数参数与返回值。</p>
</blockquote>
<h3 id="NOTE-注意"><a href="#NOTE-注意" class="headerlink" title="NOTE(注意)"></a>NOTE(注意)</h3><blockquote>
<p>&nbsp; Tuples are useful for temporary groups of related values. They are not suited to the creation of complex data structures. If your data structure is likely to persist beyond a temporary scope, model it as a class or structure, rather than as a tuple. For more information, see Classes and Structures.<br>&nbsp; 元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考类和结构体。</p>
</blockquote>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">The Swift Programming Language 中文版</a></p>
<p><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">The Swift Programming Language (Swift 3)</a></p>
<p>&lt;!— more –&gt;</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tuple-元组&quot;&gt;&lt;a href=&quot;#Tuple-元组&quot; class=&quot;headerlink&quot; title=&quot;Tuple(元组)&quot;&gt;&lt;/a&gt;Tuple(元组)&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;nbsp; Tuples group multiple values into a single compound value. The values within a tuple can be of any type and do not have to be of the same type as each other.&lt;br&gt;&amp;nbsp; 元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h4 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h4&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; person = (&lt;span class=&quot;string&quot;&gt;&quot;Vein&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;66&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&amp;nbsp; 上面这个例子中，&lt;code&gt;（“Vein”, 66）&lt;/code&gt; 是一个人的姓名和体重的元组。&lt;br&gt;&lt;code&gt;(&amp;quot;Vein&amp;quot;, 66)&lt;/code&gt; 元组把一个&lt;code&gt;String&lt;/code&gt; 和一个&lt;code&gt;Int&lt;/code&gt; 两个不同的类型组合起来。&lt;/p&gt;
&lt;p&gt;你也可以随意组合不同类型如：（&lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;、(&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;)或者（&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;)等等其他任何你想组合的元组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Learn Swift" scheme="https://github.com/VeinGuo/tags/Learn-Swift/"/>
    
  </entry>
  
  <entry>
    <title>Learn Swift - 1 (基础类型)</title>
    <link href="https://github.com/VeinGuo/2016/09/25/Learn%20Swift%20-%201%20(%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B)/"/>
    <id>https://github.com/VeinGuo/2016/09/25/Learn Swift - 1 (基础类型)/</id>
    <published>2016-09-25T03:38:42.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>&nbsp;  Apple 发布了Swift 3.0,版本语法应该相对稳定了，开始新一轮学习。</p>
<p>&nbsp;  Swift学习主要从The Basics开始学习，虽然之前已经学习过Objective-C,但还是过一遍基本的语法。</p>
<hr>
<blockquote>
<p><code>Swift</code> provides its own versions of all fundamental <code>C</code> and <code>Objective-C</code> types, including <code>Int</code> for integers, Doubleand <code>Float</code> for floating-point values, <code>Bool</code> for Boolean values, and <code>String</code> for textual data. <code>Swift</code> also provides powerful versions of the three primary collection types, <code>Array</code>, <code>Set</code>, and <code>Dictionary</code></p>
</blockquote>
<a id="more"></a>
<h3 id="Naming-Constants-and-Variables（常量与变量）"><a href="#Naming-Constants-and-Variables（常量与变量）" class="headerlink" title="Naming Constants and Variables（常量与变量）"></a>Naming Constants and Variables（常量与变量）</h3><ol>
<li>常量使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2. 变量使用 ```var</div></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> maximumNuberOfLoginAttempts = <span class="number">10</span></div><div class="line"><span class="keyword">var</span> currentLoginAttempts = <span class="number">0</span></div></pre></td></tr></table></figure>
<h3 id="Printing-Constants-and-Variables-类型标注"><a href="#Printing-Constants-and-Variables-类型标注" class="headerlink" title="Printing Constants and Variables(类型标注)"></a>Printing Constants and Variables(类型标注)</h3><p>类型和大部分变成语法相同有</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> welcomeMessage: <span class="type">String</span></div><div class="line"></div><div class="line">welcomeMessage = <span class="string">"Hi big brother"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> red, green, blue: <span class="type">Double</span></div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"你好,大兄弟。<span class="subst">\(welcomeMessage)</span>"</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> cat = <span class="string">"🐱"</span>; <span class="built_in">print</span>(cat)</div></pre></td></tr></table></figure>
<h3 id="Type-Safety-and-Type-Inference-类型安全和类型推断"><a href="#Type-Safety-and-Type-Inference-类型安全和类型推断" class="headerlink" title="Type Safety and Type Inference(类型安全和类型推断)"></a>Type Safety and Type Inference(类型安全和类型推断)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> minValue = <span class="type">UInt8</span>.<span class="built_in">min</span></div><div class="line"><span class="keyword">let</span> maxValue = <span class="type">UInt8</span>.<span class="built_in">max</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></div><div class="line"><span class="comment">//  自动推断为 Int 类型</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> pi = <span class="number">3.1415926</span></div><div class="line"><span class="comment">// 推断为 Double 类型</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> anotherPi = <span class="number">3</span> + <span class="number">0.14159</span></div><div class="line"><span class="comment">// Double 类型</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 17</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> decimalInteger = <span class="number">17</span></div><div class="line"><span class="keyword">let</span> binaryInteger = <span class="number">0b10001</span></div><div class="line"><span class="keyword">let</span> octalInteger = <span class="number">0o21</span></div><div class="line"><span class="keyword">let</span> hexadeimalInteger = <span class="number">0x11</span></div></pre></td></tr></table></figure>
<h4 id="Numeric-Type-Conversion-数字类型转换"><a href="#Numeric-Type-Conversion-数字类型转换" class="headerlink" title="Numeric Type Conversion(数字类型转换)"></a>Numeric Type Conversion(数字类型转换)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 整数转换</span></div><div class="line"><span class="comment">// let cannotBeNegative: UInt8 = -1</span></div><div class="line"><span class="comment">// UInt8 类型不能存储负数</span></div><div class="line"></div><div class="line"><span class="comment">// let tooBig: Int8 = Int8.max + 1</span></div><div class="line"><span class="comment">// Int8 类型不能存储超过最大值的数，所以会报错</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> twoThousand: <span class="type">UInt16</span> = <span class="number">2_000</span>  <span class="comment">// 这里2_000 与 2000 相同</span></div><div class="line"><span class="keyword">let</span> one: <span class="type">UInt8</span> = <span class="number">1</span></div><div class="line"><span class="keyword">let</span> twoThousandAndOne = twoThousand + <span class="type">UInt16</span>(one)</div><div class="line"></div><div class="line"><span class="comment">// UInt16 与 UInt8 整数类型相加 由于存储不同范围的值，所以必须不同情况选择性不同数值类型转换。</span></div><div class="line"><span class="comment">// UInt8 + UInt16    先把 UInt8 -&gt; UInt16 后再进行运算</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> SomeType(ofInitialValue) 是调用 Swift 构造器并传入一个初始值的默认方法。</div><div class="line"> 在语言内部，UInt16 有一个构造器，可以接受一个UInt8类型的值，所以这个构造器可以用现有的 UInt8 来创建一个新的 UInt16。</div><div class="line"> 注意，你并不能传入任意类型的值，只能传入 UInt16 内部有对应构造器的值。</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="Type-Aliases-类型别名"><a href="#Type-Aliases-类型别名" class="headerlink" title="Type Aliases(类型别名)"></a>Type Aliases(类型别名)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Type Aliases</span></div><div class="line"></div><div class="line"><span class="keyword">typealias</span> <span class="type">Vein</span> = <span class="type">UInt16</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> maxVein = <span class="type">Vein</span>.<span class="built_in">max</span></div></pre></td></tr></table></figure>
<h3 id="Booleans-布尔类型"><a href="#Booleans-布尔类型" class="headerlink" title="Booleans(布尔类型)"></a>Booleans(布尔类型)</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Booleans</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> orangesAreOrange = <span class="literal">true</span></div><div class="line"><span class="keyword">let</span> turnipsAreDelicious = <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> turnipsAreDelicious &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// this example will not compile, and will report an error</span></div><div class="line"><span class="keyword">let</span> i = <span class="number">1</span></div><div class="line"><span class="keyword">if</span> <span class="number">1</span> &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> i = <span class="number">1</span></div><div class="line"><span class="keyword">if</span> i == <span class="number">1</span> &#123;</div><div class="line">    <span class="comment">// this example will compile successfully</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// i == 1 comparison is of type Bool</span></div></pre></td></tr></table></figure>
<hr>
<p>元祖类型是我在OC中没有接触的类型，我将在下一篇学习笔记中完整的学习和分享在实际使用中的一些例子。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://wiki.jikexueyuan.com/project/swift/" target="_blank" rel="external">The Swift Programming Language 中文版</a></p>
<p><a href="https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097-CH3-ID0" target="_blank" rel="external">The Swift Programming Language (Swift 3)</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&amp;nbsp;  Apple 发布了Swift 3.0,版本语法应该相对稳定了，开始新一轮学习。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;  Swift学习主要从The Basics开始学习，虽然之前已经学习过Objective-C,但还是过一遍基本的语法。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Swift&lt;/code&gt; provides its own versions of all fundamental &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;Objective-C&lt;/code&gt; types, including &lt;code&gt;Int&lt;/code&gt; for integers, Doubleand &lt;code&gt;Float&lt;/code&gt; for floating-point values, &lt;code&gt;Bool&lt;/code&gt; for Boolean values, and &lt;code&gt;String&lt;/code&gt; for textual data. &lt;code&gt;Swift&lt;/code&gt; also provides powerful versions of the three primary collection types, &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, and &lt;code&gt;Dictionary&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Learn Swift" scheme="https://github.com/VeinGuo/tags/Learn-Swift/"/>
    
  </entry>
  
  <entry>
    <title>初入江湖</title>
    <link href="https://github.com/VeinGuo/2016/07/10/first-bolg/"/>
    <id>https://github.com/VeinGuo/2016/07/10/first-bolg/</id>
    <published>2016-07-10T06:33:05.000Z</published>
    <updated>2017-06-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用博客"><a href="#使用博客" class="headerlink" title="使用博客"></a>使用博客</h3><p>使用博客是为了把开发时踩到的坑、学习心得记录下来。</p>
<h3 id="记录下成长的点点滴滴"><a href="#记录下成长的点点滴滴" class="headerlink" title="记录下成长的点点滴滴"></a>记录下成长的点点滴滴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;About&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;Name&quot;: &quot;VeinGuo&quot;,</div><div class="line">            &quot;Email&quot;: &quot;gwrit@foxmail.com&quot;,</div><div class="line">            &quot;Hobby&quot;: &quot;Basketball , coding&quot;,</div><div class="line">            &quot;From&quot;: &quot;XiaMen,China&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用博客&quot;&gt;&lt;a href=&quot;#使用博客&quot; class=&quot;headerlink&quot; title=&quot;使用博客&quot;&gt;&lt;/a&gt;使用博客&lt;/h3&gt;&lt;p&gt;使用博客是为了把开发时踩到的坑、学习心得记录下来。&lt;/p&gt;
&lt;h3 id=&quot;记录下成长的点点滴滴&quot;&gt;&lt;a href=&quot;#记录下成长的点点滴滴&quot; class=&quot;headerlink&quot; title=&quot;记录下成长的点点滴滴&quot;&gt;&lt;/a&gt;记录下成长的点点滴滴&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;quot;About&amp;quot;: [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;quot;Name&amp;quot;: &amp;quot;VeinGuo&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;quot;Email&amp;quot;: &amp;quot;gwrit@foxmail.com&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;quot;Hobby&amp;quot;: &amp;quot;Basketball , coding&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;quot;From&amp;quot;: &amp;quot;XiaMen,China&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="初入江湖" scheme="https://github.com/VeinGuo/tags/%E5%88%9D%E5%85%A5%E6%B1%9F%E6%B9%96/"/>
    
  </entry>
  
</feed>
